<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022年周报.md</title>
    <link href="/2022/09/10/2022%E5%B9%B4%E5%91%A8%E6%8A%A5-md/"/>
    <url>/2022/09/10/2022%E5%B9%B4%E5%91%A8%E6%8A%A5-md/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>  2022年已过去半年多，年初给自己定下的目标都没有实现，越发的感觉这样下去不行，又会荒废一年。回想过去的8个多月，没有太多记忆点，自己没有什么成长，甚是懊恼。</p><p>  平时上班还每周都写周报，那虽然是应付老板，让老板有东西汇报，可是却无法给自己一个交代，浑浑噩噩的过下去不行。所以必须要做些总结复盘，这样自己才能回望过去一段时间哪些地方做的不好，要做出改进，哪些地方做的好，要继续努力下去。</p><hr /><h3 id="第46周周报">第46周周报</h3><p>本周心态略有好转，工作正常推进，另一件不想做但又不得不做的事情倒是花了不少时间，但也算收获了一点小成果。</p><p>工作方面：没太多事情，主要是开会，拉通。在另一件事情上花了一些功夫，首先是自己有一个方案A，但一直有点小瑕疵，可能是当前方案无法解决地方，需要往另一个方案B上转换才行，但是自己总觉着在方案A花了很多时间，就一直在方案A上思考，但是无法解决，后来和同事讨论，建议我往方案B上转。思考良久还是转向了方案B，花了一些时间开发出来，测试。测试的前期一直有各种BUG，差点要放弃了，当时脑中有一个念头就是不管怎样都要把这个方案调好，没有bug，要是能有收益最好，最终效果还是很好，比之前的方案有收益。</p><p>情绪方面：顾虑太多，杂念太多，当身边有人时，有点不能静下心来思考，深度的思考，后面需要调整一下这个心态。</p><p>个人刷题：每日一题，外加每天复习几道。</p><p>运动记录：30俯卧撑/天，走路1万步。</p><p>本周个人思考：</p><ul><li>主动沟通，把想法说出来，不要怕说错。</li><li>不要局限在一点，要学会发散，不能钻牛角尖。但是什么时候调整，什么时候从原有的路子上切换到另一条道路，很关键。</li></ul><hr /><h3 id="第44周周报">第44周周报</h3><p>本周算是清闲但又不完全清闲的状态，个人的工作算是有一个阶段性的完成，后续需要思考如何继续推进优化。</p><p>工作方面：有一件和个人工作不太相关的事情，自己又不得不去参与，而且需要投入不少时间，所以自己在抗拒又不得不去做的情绪下参与这项工作。最开始这件事情还挺影响心情，后来想通了，既然要投入时间就好好做吧。</p><p>情绪方面：有些许的焦虑，不过在控制范围内。因为比较劳累，所以有时候会有些情绪低落，自我调节的一般。</p><p>个人刷题：5-7道，每日一题，偶尔复习一下其它的。</p><p>运动记录：本周算是懒到家了，没有进行日常锻炼，也没有抽出大块时间去运动。</p><p>本周个人思考：</p><ul><li><p>既然不得不去投入时间去做一件事情，就好好做吧。抛弃自己抗拒的情绪，尽力去做好。</p></li><li><p>时间管理做的并不好，看到其它人的复盘，每天可以刷很多题，复习很多知识还能推进工作，相比之下，自己还是欠缺了很多。下周需要好好规划下每天不同时间段的任务了。</p></li></ul><hr /><h3 id="第42周周报">第42周周报</h3><p>国庆放假，虽说是休息，但是心还是很累，也没好好利用这段时间充电，反而是焦虑占据了一大半时间，整个假期过后感觉更累。</p><p>放假回来，继续搬砖。</p><p>工作方面：正常推进，有一个和我本职工作不相关的事情一直在心里，不想干却又不得不干，就一直拖着，而且越拖越焦虑。最后还是选择接受它，面对它，解决它，这样焦虑缓解了一些。</p><p>情绪方面：</p><ul><li>焦虑是主旋律，不过好在自己最终面对它，行动起来，缓解了挺多。</li><li>本周开始每日复盘，梳理自己每天的情绪，工作等。还是有些帮助的，可以缓解焦虑，知道自己的时间花在了哪里。</li></ul><p>个人刷题：8，算法也开始复习了。</p><p>运动记录：骑行20km，俯卧撑30/天，另外还出去参与一些其它运动。</p><p>本周个人思考：</p><ul><li>一旦开始焦虑，就要思考自己对待让自己焦虑的事情的态度。是接受 or 放弃(置之不理)，每一种选择都可以，自己内心能接受这种选择之后的结果就可以。即接受焦虑，面对焦虑，行动。</li><li>和他人讨论问题时，认真听，提供自己的意见会让自己的参与感更强一些。</li><li>不在乎他人的眼光，评价，不被这些外在的东西给束缚住了。</li></ul><hr /><h3 id="第39周周报">第39周周报</h3><p>工作方面：本周加班较多，每天工作到9:30，周六也加了一天班，整个人昏昏沉沉。</p><ul><li><p><strong>问题1</strong>：计算两个向量之间的相似度的问题，数据量百万级。但是不是两两之间，而是分组之后的两两向量之间。</p></li><li><p>想法：1、采用spark内部机器学习包中的方法，但是无法做到分组之后再计算。2、采用spark和pandas结合之后，两两计算。</p></li><li><p>方案：采用方法2。在使用numpy计算向量之间的距离时，遇到了版本问题，避免影响线上环境就没有变更依赖包的版本。只好采用较为粗暴的方式计算距离。</p></li><li><p>心得：在做这个事情时，没有完全规划好，细节没有想太多，是做完了调试之后才发现有一些细节问题没有处理好，一遍一遍的改。</p></li><li><p><strong>问题2</strong>：方案中有一个优化点，评估改优化点带来的收益。</p></li><li><p>想法：1、直接去人工看数，即人肉对比。2、制定几个指标，观察优化前后指标的变化。</p></li><li><p>方案：最终选择方案2，但是自己其实在方案1上面花了很多时间，最后才转到方案2上面。</p></li></ul><p>情绪方面：情绪稳定</p><p>个人刷题：5</p><p>运动记录：骑行0km，俯卧撑30/天</p><p>本周个人思考：</p><ul><li>想好再做，尽量多想一些细节。</li><li>想好再说，不着急回答问题。</li><li>有些事情可以后台(广义)运行，注意力不要被完全牵制。</li><li>抛弃假想敌，不为还没发生的事情担心。</li></ul><hr /><h3 id="第38周周报">第38周周报</h3><p>工作方面：正常的项目推进，技术方面没有成长。</p><p>情绪方面：没有控制好情绪，讨论问题时，若别人的想法和自己不一致，自己会莫名的代入你要改变我的想法，就会语气或表情有些不好，不过自己也快速的意识到了问题，快速的调整到正常交流沟通的状态。<strong>未来要淡定，说话不急不躁，声音要洪亮。</strong></p><p>个人成长：刷题10+。</p><p>运动记录：骑行90km，俯卧撑50。</p><p>Todo：输出一篇博客，可以是算法总结，也可以是刷题分享，一定要做，先做起来。</p>]]></content>
    
    
    <categories>
      
      <category>周报</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightGBM算法原理</title>
    <link href="/2022/06/26/LightGBM%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <url>/2022/06/26/LightGBM%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>  在 <a href="https://silencemao.github.io/2022/04/05/XGBoost%E4%BB%8B%E7%BB%8D/">XGBoost介绍</a>中，我们讲述了xgb的运行原理，节点分裂方式。在xgb出现之后，迅速的应用在工业界中并取得了非常好的效果。但是仍然存在一些问题，比如当数据规模巨大的情况下，运行速度慢，不能直接支持类别特征等。在2017年，微软发布了一个新的GBDT算法框架<strong>LightGBM</strong>，与xgb相比，达到相同的算法效果，运行速度更快，并且支持类别特征。lgb的主要改进点是提升模型速度，从两个维度进行了优化，分别是样本维度和特征维度。本文基于lgb的论文进行总结归纳，以便时常温习回顾。</p><h3 id="一主要改进点">一、主要改进点</h3><ol type="1"><li>直方图算法（histogram-based algorithm）：基于连续特征值进行分桶bin，然后基于不同的bin进行分裂。相比于预排序算法，节省内存和提升速度。</li><li>单边梯度采样算法GOSS（Gradient-based One-Side Sampling）：计算增益过程中，不再使用全部样本，而是筛选出一部分梯度大的样本和部分梯度小的样本计算增益。减少样本数量，提升计算速度。</li><li>互斥特征绑定算法EFB（Exclusive Feature Bundling）：在高维稀疏特征中，部分特征并不会同时非零，所以可以将其中几个特征绑定为一个特征，进行分裂。减少特征数量，提升计算速度。</li><li>叶子节点生长策略（leaf-wise tree growth strategy）：xgb在树的生成过程中，每次都是一层的所有节点都进行分裂，lgb是每次选择所有叶节点中收益最大的节点分裂，有利有弊，利：降低模型误差，弊：树生长过深，可能会过拟合。</li></ol><span id="more"></span><h3 id="二直方图算法">二、直方图算法</h3><p><strong>寻找最佳分割点，如何才能更高效？</strong>这就是直方图算法要解决的问题。GBDT算法是基于决策树的ensemble模型，树的每次生长都是要寻找分割点，将数据分到左子树和右子树中，如何寻找这个分割点是非常耗时的。一种是预排序算法，即将特征f的所有取值从小到大排序，然后遍历每一个特征取值<span class="math inline">\(f_{i}\)</span>，分别以<span class="math inline">\(f_{i}\)</span>为分割点，计算增益，选取最大的增益对应的分割点作为当前的分割节点。一种方法是直方图算法，即将连续特征离散化，分到指定的几个bin内，比如特征取值1-10分到bin=1内，10-20分到bin=2内....。寻找最佳分割点时直接根据bin的取值来分割即可。二者相比时间复杂度分别为O(data<em>feature)和O(bin</em>fenture)，feature表示特征维度，data表示样本数量，bin表示桶数量。</p><figure><img src="/images/lgb_alg1_his.png" alt="直方图算法" /><figcaption aria-hidden="true">直方图算法</figcaption></figure><p>上图就是直方图算法的主题逻辑。</p><h3 id="三goss采样策略">三、GOSS采样策略</h3><p><strong>GOSS采样策略的灵感来自于Adaboost</strong>，在adaboost中，样本是有权重的，样本的误差越大，权重越高，在下次训练时模型会更加关注误差更大的样本。但是在GBDT算法中样本是没有权重的，无法直接将Adaboost的方式迁移过来。但是在GBDT算法中，样本的梯度越小，则误差越小，表示该样本被训练的更好，所以误差和梯度之间也是有一定关系的。因此是否可以考虑将这部分训练的很好地样本丢掉，但是直接丢掉样本会影响分布。所以LightGBM提出依据样本梯度进行采样的策略。思路很简单，</p><ol type="1"><li><p>按照样本梯度绝对值从大到小排序</p></li><li><p>选取topa%梯度较大的样本，然后再选取b%梯度较小的样本（b是指全部样本的b%）</p></li><li><p>对采样出来的小梯度样本乘以(1-a)/b，提升小梯度样本的权重（1-a是表示小梯度样本的分布，大梯度样本的分布是a，1/b是将小梯度样本的比例放大b倍）。</p><figure><img src="/images/lgb_alg2_goss.png" alt="GOSS算法" /><figcaption aria-hidden="true">GOSS算法</figcaption></figure></li></ol><p>上图是GOSS算法的整体逻辑。</p><h3 id="四互斥特征绑定算法">四、互斥特征绑定算法</h3><p>互斥特征绑定的目的是降低特征维度，减少计算量，其实也有点类似于列采样。在高维稀疏特征中，很多特征并不会同时非零。即多个特征可以合并成一维特征，LightGBM采用了互斥特征绑定算法（EFB）来降低特征维数。将特征进行分桶，桶内特征是互斥的，然后将桶内特征合并成一个特征再去进行分裂。这样可以将数据从O(data<em>feature)降低到O(data</em>buddle)。该方法实现起来存在两大难点：</p><ol type="1"><li>哪些特征可以放在一起</li><li>如何构建buddle</li></ol><h4 id="哪些特征可以绑定">4.1哪些特征可以绑定</h4><p>对于第一个问题，EFB算法是构建了一个图G=(V,E)，图的顶点E是特征，顶点之间的边V表示特征之间的冲突数，将存在冲突的两个顶点构建一条边。然后将不存在冲突的顶点放到一个集合内，构成一个特征包。在LightGBM中，为了提升效率，它是允许一部分特征之间存在一定的冲突的，即允许存在<span class="math inline">\(gamma\)</span>个冲突。通过控制<span class="math inline">\(gamma\)</span>的大小，可以让算法精度和效率有一定的平衡。算法思路为：</p><ol type="1"><li>构建加权图，V表示两个特征之间的冲突数</li><li>将特征按照冲突数降序排列，分配特征到不同的特征包内</li><li>通过控制特征包内最大冲突数K来决定该特征是放入已有特征包内还是新建特征包</li><li>这样算法思路为O(feature*feature)，因为要两两遍历特征之间的冲突</li></ol><p>这样做对于特征维度较小时还可以完成，维度一旦百万级就无法承受了。</p><figure><img src="/images/lgb_alg3_efb.png" alt="efb算法" /><figcaption aria-hidden="true">efb算法</figcaption></figure><p>因此为了简化上述计算特征冲突数的过程，采样一个特征下非0的样本数量，一个特征下非0值特征越多，则越容易冲突。</p><h4 id="如何构建buddle">4.2如何构建buddle</h4><p>上面解决了如何判断哪些特征要被绑定在一起，那么EFB算法如何绑定特征呢？如何既减少了特征维度，又保证原始的特征值可以在特征包中被识别出来呢？由于LightGBM是采用直方图算法减少对于寻找最佳分裂点的算法复杂度，直方图算法将特征值离散到若干个bin中。这里EFB算法为了保留特征，将bundle内不同的特征加上一个偏移常量，使不同特征的值分布到bundle的不同bin内。例如：特征A的取值范围为[0,10)，特征B的原始取值范围为[0，20)，对特征B的取值上加一个偏置常量10，将其取值范围变为[10,30)，这样就可以将特征A和B绑定在一起了。具体的算法流程上图Algorithm4所示。</p><h3 id="五按叶子生长leaf-wise">五、按叶子生长（leaf-wise）</h3><p>在xgb中，决策树的构建是按照层生长的。每次都是把一层的节点都进行分裂，这种操作复杂度会高，而且一层中未必所有节点都有很高的收益。所以在LightGBM中是按照叶子节点生长的，每次选择所有叶子节点中收益最大的那个节点进行分裂，依次循环下去。和xgb相比，优点是lgb减少了一部分收益较小的节点分裂开销，生成的树较深，更容易降低误差，缺点是树较深，有可能会过拟合，所以lgb有一个控制树的深度的参数，防止过拟合。</p><h3 id="六总结">六、总结</h3><p>lgb效率更高主要得益于它的几个优化点，</p><ol type="1"><li>分裂的时候采用直方图算法，相当于减少计算的样本数</li><li>计算增益的时候的采用GOSS算法，对样本采样，也是减少样本数</li><li>对于高维稀疏特征采用EFB算法，相当于降低特征维度</li><li>树的生长采用按叶子生长，减少不必要的计算开销</li></ol><p>万变不离其宗，主题核心就是<strong>减少样本数或者减少特征数两个点展开</strong>，结果也验证了作者的想法。</p><p>Ref:</p><p><a href="/images/lgb_alg1_his.png">https://zhuanlan.zhihu.com/p/59631419</a></p><p><a href="http://www.csuldw.com/2019/07/24/2019-07-24-an-introduction-tolightGBM-explained/">http://www.csuldw.com/2019/07/24/2019-07-24-an-introduction-tolightGBM-explained/</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark和Pandas结合使用.md</title>
    <link href="/2022/05/21/Spark%E5%92%8CPandas%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8-md/"/>
    <url>/2022/05/21/Spark%E5%92%8CPandas%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8-md/</url>
    
    <content type="html"><![CDATA[<p>  本篇文章主要讲解spark和pandas结合应用的一个例子，我之前在工作中总是单纯的使用spark，有时候会将DataFrame转换为临时表，然后使用Hive-sql处理，或者是写Udf做稍微复杂一些的处理。在前段时间接触到spark可以和pandas结合使用，还真是又涨了点知识。</p><p>  举一个例子，一个DataFrame的size是[m,n]，我想对其进行groupby操作，然后返对每个分组内的上下两个row进行一些操作，最后返回一个和和原DataFrame大小一致的新df，最初我想到的一个方案是对组内每两行先打一个相同的tag，然后再结合window进行操作，不过这种方案比较麻烦，不直观，而且对每两行之间做一些复杂的运算可能也不是很友好。或者另一个场景，一个df，第一列是id，第二列是不同的品牌，想要统计某个id下各个品牌的数量(可以有重复)，这时一种常规的方案是对每个品牌进行映射到一个新的列，然后若这一行是品牌1，则打标记为1，其它为0，品牌2的列同理，这样处理起来略显麻烦，pandas就可以很简单的处理。</p><p>  再举一个例子，我想对df分组，计算组内分位数，但是我要求分位数必须是组内出现的数字，而不是插值之后的数字，并且还要对一些异常值进行判断。你可能会想到使用hivesql中的percentile来做，但是它返回的未必是组内的值，而且对异常值判断不是很方便。</p><p>  对于上面两个例子，单纯的使用spark和hivesql都不是最优雅的方案，这时候pandas就出现了，它可以很好地解决这两类问题。</p><span id="more"></span><h2 id="一环境介绍">一、环境介绍</h2><p>  简单介绍下我所应用的环境：首先是要安装pyarrow这个库，其次python版本不要高于3.7，最后spark环境，我之前使用的是2.4，一直报错，折腾了好久，后来发现是环境问题，切换到3.2就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">spark:spark-3.2.0-bin-hadoop2.7<br>python:3.7<br>pyarrow:8.0.0<br></code></pre></td></tr></table></figure><h2 id="二spark与pandas结合">二、Spark与Pandas结合</h2><p>  spark和pandas结合其实就是把一部分sparkdataframe，转换为pandas dataframe，然后可以比较方便的进行数值计算，就像写单机pandas操作一样。</p><p>  我们需要用到 <strong>pyspark.sql.functions import pandas_udf, PandasUDFType</strong>，这两个函数，顾名思义，pandas_udf就是用户自定义的pandas函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pandas_udf</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    f: PandasScalarToScalarFunction,</span></span><br><span class="hljs-params"><span class="hljs-function">    returnType: <span class="hljs-type">Union</span>[AtomicDataTypeOrString, ArrayType],</span></span><br><span class="hljs-params"><span class="hljs-function">    functionType: PandasScalarUDFType,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) -&gt; UserDefinedFunctionLike:</span> ...<br><br></code></pre></td></tr></table></figure><p>pandas_udf就三个参数：</p><ul><li><p>f：即用户自定义的func</p></li><li><p>returnType：自定义的func返回的值类型</p></li><li><p>functionType：枚举值，包含下面四种方式，表示的是我们的函数是按照什么样的方式进行映射，即返回值和输入是怎样的映射关系:</p><p>SCALAR: PandasScalarUDFType ：标量，即返回一个值 SCALAR_ITER: PandasScalarIterUDFType ：迭代器，这个还需要我探索一下 GROUPED_MAP: PandasGroupedMapUDFType ：分组映射，分组之后返回df，可以和原df大小一致，也可不一致，用户自己可以控制 GROUPED_AGG: PandasGroupedAggUDFType ：分组聚合，分组之后返回一个常量值</p></li></ul><p> <strong> 今天主要介绍一下GROUPED_MAP和GROUP_AGG的用法。</strong></p><table><thead><tr class="header"><th>方法</th><th>输入</th><th>输出</th><th>配合使用方式</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>GROUPED_MAP</td><td>Datafram</td><td>Dataframe</td><td>Apply</td><td></td><td></td></tr><tr class="even"><td>GROUPED_AGG</td><td>一列或多列</td><td>常量</td><td>agg</td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="grouped_agg">1、GROUPED_AGG</h3><p>  就拿上面那个计算组内分位数的例子来做，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> findspark<br>findspark.init(<span class="hljs-string">&quot;/usr/local/spark-3.2.0-bin-hadoop2.7&quot;</span>)<br><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> SparkSession<br><span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> functions <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> types <span class="hljs-keyword">as</span> T<br><span class="hljs-keyword">from</span> pyspark.sql.functions <span class="hljs-keyword">import</span> pandas_udf, PandasUDFType<br><br><br>spark = SparkSession.builder.appName(<span class="hljs-string">&#x27;xxx&#x27;</span>).config(<span class="hljs-string">&quot;spark.driver.host&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>).config(<span class="hljs-string">&quot;spark.driver.bindAddress&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>).getOrCreate()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">self</span>):</span><br>        df = spark.createDataFrame(<br>            [(<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">3.16</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">2.168</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">1.915</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">4</span>),<br>             (<span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">1.509</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">2</span>)],<br>            [<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;max_wheel&quot;</span>, <span class="hljs-string">&quot;cnt&quot;</span>])<br>        df.show()<br>        <span class="hljs-comment"># 定义pandas_udf，输入函数、返回值类型，聚合类型</span><br>        mean_udf = F.pandas_udf(M.__t_agg, <span class="hljs-string">&quot;string&quot;</span>, F.PandasUDFType.GROUPED_AGG)<br>        <span class="hljs-comment"># 应用udf，注意是使用agg，传入两列</span><br>        df = df.groupBy([<span class="hljs-string">&quot;id&quot;</span>]).agg(mean_udf(df[<span class="hljs-string">&quot;max_wheel&quot;</span>], df[<span class="hljs-string">&quot;cnt&quot;</span>]).alias(<span class="hljs-string">&quot;res&quot;</span>))<br>        df.show()<br><br>        df = df.withColumn(<span class="hljs-string">&quot;res&quot;</span>, F.split(df[<span class="hljs-string">&quot;res&quot;</span>], <span class="hljs-string">&quot;,&quot;</span>))<br>        df = df.withColumn(<span class="hljs-string">&quot;r1&quot;</span>, df[<span class="hljs-string">&quot;res&quot;</span>].getItem(<span class="hljs-number">0</span>)).withColumn(<span class="hljs-string">&quot;r2&quot;</span>, df[<span class="hljs-string">&quot;res&quot;</span>].getItem(<span class="hljs-number">1</span>))<br>        df.show()<br>        df.<span class="hljs-built_in">filter</span>(df[<span class="hljs-string">&quot;id&quot;</span>] == <span class="hljs-string">&#x27;a1&#x27;</span>).show()<br><br>    <span class="hljs-comment"># 定义具体的函数</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__t_agg</span>(<span class="hljs-params">v1, v2</span>):</span><br>        df = pd.DataFrame(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(v1, v2)), columns=[<span class="hljs-string">&quot;max_wheel&quot;</span>, <span class="hljs-string">&quot;cnt&quot;</span>])  <span class="hljs-comment"># 传入两列，转换为df</span><br>        a1 = <span class="hljs-built_in">round</span>(df[<span class="hljs-string">&quot;max_wheel&quot;</span>].quantile(q=<span class="hljs-number">0.5</span>, interpolation=<span class="hljs-string">&quot;lower&quot;</span>), <span class="hljs-number">2</span>) <span class="hljs-comment"># 不插值</span><br>        a2 = <span class="hljs-built_in">round</span>(df[<span class="hljs-string">&quot;cnt&quot;</span>].quantile(q=<span class="hljs-number">0.5</span>, interpolation=<span class="hljs-string">&quot;lower&quot;</span>), <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;,&quot;</span>.join([<span class="hljs-built_in">str</span>(a1), <span class="hljs-built_in">str</span>(a2)])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    m = M()<br>    m.f()<br><br>--------------------------------------------------------------<br>输入<br>+---+---------+---+<br>| <span class="hljs-built_in">id</span>|max_wheel|cnt|<br>+---+---------+---+<br>| a1|      <span class="hljs-number">2.2</span>|  <span class="hljs-number">5</span>|<br>| a1|     <span class="hljs-number">3.16</span>|  <span class="hljs-number">1</span>|<br>| a1|    <span class="hljs-number">2.168</span>|  <span class="hljs-number">3</span>|<br>| a1|      <span class="hljs-number">2.5</span>|  <span class="hljs-number">4</span>|<br>| a2|    <span class="hljs-number">1.915</span>|  <span class="hljs-number">2</span>|<br>| a2|      <span class="hljs-number">2.0</span>|  <span class="hljs-number">4</span>|<br>| a2|    <span class="hljs-number">1.509</span>|  <span class="hljs-number">1</span>|<br>| a2|      <span class="hljs-number">2.1</span>|  <span class="hljs-number">2</span>|<br>+---+---------+---+<br><br>--------------------------------------------------------------<br>输出<br>+---+---------+----+---+<br>| <span class="hljs-built_in">id</span>|      res|  r1| r2|<br>+---+---------+----+---+<br>| a1| [<span class="hljs-number">2.2</span>, <span class="hljs-number">3</span>]| <span class="hljs-number">2.2</span>|  <span class="hljs-number">3</span>|<br>| a2|[<span class="hljs-number">1.92</span>, <span class="hljs-number">2</span>]|<span class="hljs-number">1.92</span>|  <span class="hljs-number">2</span>|<br>+---+---------+----+---+<br></code></pre></td></tr></table></figure><h3 id="grouped_map">2、GROUPED_MAP</h3><p>  就拿上面计算每个id下不同品牌的数量的例子来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span>(<span class="hljs-params">self</span>):</span><br>        df = spark.createDataFrame(<br>            [(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>), (<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>),(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>),<br>             (<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>), (<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>), (<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>),(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)],<br>            [<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;brand&quot;</span>])<br>        df.show()<br>        <span class="hljs-comment"># 设置返回类型，包括返回的列名，每列值的类型</span><br>        schema = T.StructType()<br>        schema.add(T.StructField(<span class="hljs-string">&quot;id&quot;</span>, T.StringType(), <span class="hljs-literal">True</span>))<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]:<br>            schema.add(T.StructField(col, T.IntegerType(), <span class="hljs-literal">True</span>))<br>        <span class="hljs-built_in">print</span>(schema)<br>        <br>        <span class="hljs-comment"># 构建pandas_udf</span><br>        cnt_udf = F.pandas_udf(M.__t_map, schema, F.PandasUDFType.GROUPED_MAP)<br>        <span class="hljs-comment"># 引用udf，传入的相当于整个df，注意使用的是apply</span><br>        df1 = df.groupBy([<span class="hljs-string">&quot;id&quot;</span>]).apply(cnt_udf)<br>        df1.show()<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__t_map</span>(<span class="hljs-params">df</span>):</span><br>        res = &#123;<span class="hljs-string">&quot;id&quot;</span>: [], <span class="hljs-string">&quot;a&quot;</span>: [],  <span class="hljs-string">&quot;b&quot;</span>: [],  <span class="hljs-string">&quot;c&quot;</span>: [],  <span class="hljs-string">&quot;d&quot;</span>: []&#125;<br>        <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():<br>            <span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 返回的df是groupby之后的，若没有此操作，则返回的df是和原df大小一致的</span><br>                <span class="hljs-keyword">break</span><br>            res[<span class="hljs-string">&quot;id&quot;</span>].append(row[<span class="hljs-string">&quot;id&quot;</span>])<br><br>        res[<span class="hljs-string">&quot;a&quot;</span>].append(df[df[<span class="hljs-string">&quot;brand&quot;</span>] == <span class="hljs-string">&#x27;a&#x27;</span>].shape[<span class="hljs-number">0</span>])<br>        res[<span class="hljs-string">&quot;b&quot;</span>].append(df[df[<span class="hljs-string">&quot;brand&quot;</span>] == <span class="hljs-string">&#x27;b&#x27;</span>].shape[<span class="hljs-number">0</span>])<br>        res[<span class="hljs-string">&quot;c&quot;</span>].append(df[df[<span class="hljs-string">&quot;brand&quot;</span>] == <span class="hljs-string">&#x27;c&#x27;</span>].shape[<span class="hljs-number">0</span>])<br>        res[<span class="hljs-string">&quot;d&quot;</span>].append(df[df[<span class="hljs-string">&quot;brand&quot;</span>] == <span class="hljs-string">&#x27;d&#x27;</span>].shape[<span class="hljs-number">0</span>])<br><br>        res_df = pd.DataFrame(res)<br>        <span class="hljs-keyword">return</span> res_df<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    m = M()<br>    <span class="hljs-comment"># m.f()</span><br>    m.f1()<br>    <br>--------------------------------------------------------------<br>输入<br>+---+-----+<br>| <span class="hljs-built_in">id</span>|brand|<br>+---+-----+<br>| a1|    a|<br>| a1|    b|<br>| a1|    c|<br>| a1|    a|<br>| a1|    d|<br>| a1|    a|<br>| a1|    d|<br>| a2|    c|<br>| a2|    b|<br>| a2|    c|<br>| a2|    b|<br>| a2|    d|<br>| a2|    a|<br>| a2|    c|<br>+---+-----+<br>--------------------------------------------------------------<br>输出<br>+---+---+---+---+---+<br>| <span class="hljs-built_in">id</span>|  a|  b|  c|  d|<br>+---+---+---+---+---+<br>| a1|  <span class="hljs-number">3</span>|  <span class="hljs-number">1</span>|  <span class="hljs-number">1</span>|  <span class="hljs-number">2</span>|<br>| a2|  <span class="hljs-number">1</span>|  <span class="hljs-number">2</span>|  <span class="hljs-number">3</span>|  <span class="hljs-number">1</span>|<br>+---+---+---+---+---+<br></code></pre></td></tr></table></figure><h2 id="三总结">三、总结</h2><p>  好了，这就是本篇文章对pyspark和pandas一起应用的一个例子，分别介绍了GROUP_AGG和GROUP_MAP两个场景，后续还需要再补充一个SCALAR_ITER的应用，希望能对您有用。</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XGBoost介绍</title>
    <link href="/2022/04/05/XGBoost%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/04/05/XGBoost%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一简介">一、简介</h1><p>  XGBoost(eXtreme Gradient Boosting)又叫极度梯度提升树，是boosting算法的一种实现方式。针对分类或回归问题，效果非常好。在各种数据竞赛中大放异彩，而且在工业界也是应用广泛，主要是因为其效果优异，使用简单，速度快等优点。本文主要从以下几个方面介绍该算法模型：</p><p><img src="/images/xgb.png" /></p><h1 id="二基本原理">二、基本原理</h1><p>  xgb是boosting算法的一种实现方式，主要是降低偏差，也就是降低模型的误差。因此它是采用多个基学习器，每个基学习器都比较简单，避免过拟合，下一个学习器是学习前面基学习器的结果<span class="math inline">\(y^{t}_{i}\)</span>和实际值<span class="math inline">\(y_{i}\)</span>的差值，通过多个学习器的学习，不断降低模型值和实际值的差。 <span class="math display">\[y_{i}^{0} = 0\]</span> <span class="math display">\[y_{i}^{1} = f_{1}(x_{i}) = y_{i}^{0}+f_{1}(x_{i})\]</span> <span class="math display">\[$y_{i}^{2}=f_{1}(x_{i})+f_{2}(x_{i})=y_{i}^{1}+f_{2}(x_{i})\]</span> <span class="math display">\[y_{i}^{t}=\sum_{k=1}^{t}f_{k}(x_{i})=y_{i}^{t-1}+f_{t}(x_{i})\]</span> 基本思路就是不断生成新的树，每棵树都是基于上一颗树和目标值的差值来进行学习，从而降低模型的偏差。最终模型结果的输出如下：<span class="math inline">\(y_{i}=\sum_{k=1}^{t}f_{k}(x_{i})\)</span>，即所有树的结果累加起来才是模型对一个样本的预测值。那在每一步如何选择/生成一个较优的树呢？那就是由我们的<strong>目标函数</strong>来决定。</p><h1 id="三目标函数">三、目标函数</h1><p>  目标函数由两部分组成，一是模型误差，即样本真实值和预测值之间的差值，二是模型的结构误差，即正则项，用于限制模型的复杂度。 <span class="math display">\[Obj(\theta)=L(\theta)+\Omega(\theta)=L(y_{i},y_{i}^{t})+\sum_{k=1}^{t}\Omega(f_{k}(x_{i}))\]</span> 因为<span class="math inline">\(y_{i}^{t}=y_{i}^{t-1}+f_{t}(x_{i})\)</span>，所以将其带入上面的公式中转换为： <span class="math inline">\(Obj^{t}=\sum_{n=1}^{n}L(y_{i},y_{i}^{t-1}+f_{t}(x_{i}))+\Omega(f_{t})+\sum_{t=1}^{T-1}\Omega(f_{t})\)</span>，第t颗树的误差由三部分组成，n个样本在第t颗树的误差求和，以及第t颗树的结构误差和前t-1颗树的结构误差。其中前t-1颗树的结构误差是常数，因为我们已经知道前t-1颗树的结构了。   <strong>假设</strong>我们的损失函数是平方损失函数(mse)，则上述目标函数转换为： <span class="math display">\[Obj^{t}=\sum_{i=1}^{n}L(y_{i},y_{i}^{t-1}+f_{t}(x_{i}))+\Omega(f_{t})+\sum_{t=1}^{T-1}\Omega(f_{t}) \\ =\sum_{i=1}^{n}(y_{i}-(y_{i}^{t-1}+f_{t}(x_{i})))^2+\Omega(f_{t})+constant\]</span> 上述公式即为损失函数为mse时xgb第t步的目标函数。唯一的变量即为<span class="math inline">\(f_{t}\)</span>，此处的损失函数仍然是一个相对复杂的表达式，所以为了简化它，采用二阶泰勒展开来近似表达，即<span class="math display">\[f(x+\Delta x)=f(x)+f^{&#39;}(x)\Delta x+1/2f^{&#39;&#39;}(x)\Delta x^2\]</span>，所以另<span class="math inline">\(g_{i}=\partial _{y_{i}^{t-1}}l(y_{i},y_{i}^{t-1})\)</span>，<span class="math inline">\(h_{i}=\partial _{y_{i}^{t-1}} ^ 2 l(y_{i},y_{i}^{t-1})\)</span>，即分别是<span class="math inline">\(l(y_{i},y_{i}^{t-1})\)</span>的一阶导和二阶导。则上述损失函数转换为二阶导之后，<span class="math display">\[Obj^{t}=\sum_{i=1}^{n}[l(y_{i},y_{i}^{t-1})+g_{i} f_{t}(x_{})+1/2h_{i} f_{t}^2(x)]+\Omega(f_{t})+constant\]</span>，   所以当损失函数是mse时，<span class="math inline">\(g_{i}=2(y_{i}^{t-1}-y_{i})\)</span>，<span class="math inline">\(h_{i}=2\)</span>。   经过转换之后，其中第一项是所有样本与第t-1颗树的误差之和，因为第t-1颗树是已知的，所以可以将其视为常数项，我们暂时在目标函数中将其舍去，我们的目标函数变为关于<span class="math inline">\(f_{t}(x)\)</span>的函数了。而<span class="math inline">\(f_{t}(x)\)</span>则是关于叶子节点输出<span class="math inline">\(w\)</span>的函数，所以我们的目标函数全部转换为关于<span class="math inline">\(w\)</span>的函数，<span class="math display">\[Obj^{t}=\sum_{i=1}^{n}[g_{i} f_{t}(x_{})+1/2h_{i} f_{t}^2(x)]+\Omega(f_{t})+constant \\ =\sum_{i=1}^{n}[g_{i}w_{q}(x_{i})+1/2h_{i}w_{q}^2(x_{i})]+\gamma T+1/2\lambda\sum_{j=1}^{T}w_{j}^{2} \\ =\sum_{j=1}^{T}[\sum_{i \in I_{j}}(g_{i})*w_{j}+1/2*\sum_{i \in I_{j}}(h_{i}+\lambda)w_{j}^2]+\gamma T\]</span>。我们令<span class="math inline">\(G_{j}=\sum_{i \in I_{j}}(g_{i})\)</span>，令<span class="math inline">\(H_{j}=\sum i \in I_{j}(h_{i})\)</span>，则我们的目标函数转换为<span class="math display">\[Obj^{t}=\sum_{j=1}^{T}G_{j}*w_{j}+1/2(H_{j}+\lambda)*w_{j}^{2}+\lambda T\]</span>。在上述表达式中，<span class="math inline">\(j表示第j个节点\)</span>，<span class="math inline">\(i表示第i个样本\)</span>。所以整个目标函数转换成了关于<span class="math inline">\(w\)</span>即叶节点分数的一元二次函数，想要优化目标函数，就是求解最优的w，因此我们对目标求导，得到<span class="math display">\[w^{*}=-G_{i}/(H_{i}+\lambda)\]</span>，将<span class="math inline">\(w^{*}\)</span>代入目标函数中，则目标函数变为<span class="math display">\[Obj^{t}=-1/2\sum_{j=1}^{T}G_{j}^{2}/(H_{j}+\lambda)+\lambda T\]</span>。如此简单，所以在求解二叉树的目标函数时，只要知道损失函数的一阶导、二阶导，以及样本落在哪个叶子节点上，我们只要求出在每个叶子节点上，该样本的一阶导和二阶导就能求出目标函数。也就能决定是否分裂该节点，依据哪个节点的特征值来进行分裂。</p><h2 id="三节点分裂">三、节点分裂</h2><p>   xgb节点是否分裂取决于信息增益的变化，若分裂当前节点，信息增益&gt;0，则进行分裂，若不大于0则不分裂，如何判断分列前后信息增益的变化呢。那就可以使用我们的目标函数来表示了。 <span class="math display">\[Gain=G_{L}^{2}/(H_{L}+\lambda)+G_{R}^{2}/(H_{R}+\lambda)-(G_{L}+G_{R})^2/(H_{L}+H_{R}+\lambda)+\gamma\]</span>   节点分裂有两种方式：1、贪心算法，2、近似算法。</p><h3 id="贪心算法">3.1 贪心算法</h3><p>  贪心算法分裂的方式就是一种暴力搜索的方式，遍历每一个特征，遍历该特征的每一个取值，计算分裂前后的增益，选择增益最大的特征取值作为分裂点。 <img src="/images/xgb1.png" alt="贪心算法" /> 分裂流程如上图所示。</p><h3 id="近似算法">3.2 近似算法</h3><p>   近似算法，其实就是分桶，目的是为了提升计算速度，降低遍历的次数，所以对特征进行分桶。就是将每一个特征的取值按照分位数划分到不同的桶中，利用桶的边界值作为分裂节点的候选集，每次遍历时不再是遍历所有特征取值，而是仅遍历该特征的几个桶（每个桶可以理解为该特征取值的分位数）就可以，这样可以降低遍历特征取值的次数。</p><figure><img src="/images/xgb2.png" alt="近似算法" /><figcaption aria-hidden="true">近似算法</figcaption></figure><p>  分桶算法分为global模式和local模式，global模式就是在第一次划分桶之后，不再更新桶，一直使用划分完成的桶进行后续的分裂。这样做就是计算复杂度降低，但是经过多次划分之后，可能会存在一些桶是空的，即该桶中已经没有了数据。   local模式就是在每次分列前都重新划分桶，优点是每次分桶都能保证各桶中的样本数量都是均匀的，不足的地方就是计算量大。</p><h2 id="四其它特点">四、其它特点</h2><h3 id="缺失值处理">4.1 缺失值处理</h3><p>   对于存在某一维特征缺失的样本，xgb会尝试将其放到左子树计算一次增益，再放到右子树计算一次增益，对比放在左右子树增益的大小决定放在哪个子树。</p><h3 id="防止过拟合">4.2 防止过拟合</h3><p>   xgb提出了两种防止过拟合的方法：第一种称为Shrinkage，即学习率，在每次迭代一棵树的时候对每个叶子结点的权重乘上一个缩减系数，使每棵树的影响不会过大，并且给后面的树留下更大的空间优化。另一个方法称为Column Subsampling，类似于随机森林选区部分特征值进行建树，其中又分为两个方式:方式一按层随机采样，在对同一层结点分裂前，随机选取部分特征值进行遍历，计算信息增益；方式二在建一棵树前随机采样部分特征值，然后这棵树的所有结点分裂都遍历这些特征值，计算信息增益。</p><h2 id="五总结">五、总结</h2><p>  以上是对xgb的一些理解，大多是观看了很多大神的博客，通过不断的看别人总结的部分以及公式的推导，才让我逐渐理解xgb的各种特征。本文还是有很多不足的地方，后续逐渐补充，完善。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2022/01/03/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2022/01/03/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树">决策树</h2><h3 id="决策树三要素">决策树三要素</h3><ol type="1"><li><p>特征选择</p></li><li><p>决策树生成</p></li><li><p>决策树剪枝</p><ol type="1"><li><p>预剪枝</p><p>限制树的深度，叶子节点个数，叶子节点样本数，信息增益等</p></li><li><p>后剪枝</p><p>正则化</p></li></ol></li></ol><h3 id="id3">ID3</h3><p>  ID3是根据信息增益来选择特征，将数据划分成多份，构成决策树。</p><h4 id="信息增益">信息增益</h4><p>  信息增益是什么呢？划分数据前后 数据中<strong>“信息量”</strong>的 变化，通常选择信息增益最大的特征作为当前划分的依据。</p><h4 id="信息熵">信息熵</h4><p>  如何衡量<strong>“信息量”</strong>呢？这里引入熵的概念，熵表示信息不确定性的程度，熵越大，不确定性越强，熵越小，不确定性越小(越确定)。熵的公式如下：</p><p><span class="math display">\[H(X)=-sum_{i=1}^{i=n}p_{i}*log(p_{i})\]</span></p><p>  n样本是分类的个数，<span class="math inline">\(p_{i}\)</span>表示样本分类为类别i的概率。熵的大小是和每个类别的概率有关的。</p><p><img src="/images/entropy.png" /></p><p>  熵和概率的关系如上图所示：随着概率从小变大，熵的值先增大道最大值然后降到最小值，当概率值<span class="math inline">\(p=0.5\)</span>时，熵值最大，说明不确定性越大，当概率值<span class="math inline">\(p=0.9\)</span>时，熵值最小，不确定性越小。</p><h4 id="条件熵">条件熵</h4><p>  对于条件熵，则是当X的取值确定之后，在这个条件下的熵值。即当我们确定了样本某特征X的取值之后，即在这个条件下的熵值，</p><p><span class="math display">\[H(Y|X)=sum_{i=1}^{i=n}p_{i}*H(Y|X=x_{i})\]</span></p><p>  举个例子我们有一波样本D，共有k个类别<span class="math inline">\(C_{k}\)</span>，它的熵为H(D)，某一特征A有n个取值，依据特征A可以将数据集划分为n个子集，分别为<span class="math inline">\(D_{1}\)</span>，<span class="math inline">\(D_{2}\)</span>...<span class="math inline">\(D_{n}\)</span>，首先计算每个子集的信息熵H(D|A)，然后计算每个子集的样本占总样本的比例<span class="math inline">\(p_{i}\)</span>，然后将每个子集的信息熵*比例 加起来，就是特征A的条件熵。</p><p>  所以回到ID3算法上，特征A对数据集D的信息增益就是<span class="math display">\[g(D,A)=H(D)-H(D|A)\]</span>。</p><p>  在生成树的过程中，每次分裂时选择特征就是依据信息增益来选择最佳分裂点。选好最佳分裂点之后，依据特征取值将样本分成n(特征A取值的个数)叉树，然后在每个子树下面继续进行分裂，直到树生成完成。</p><h4 id="id3算法的缺点">ID3算法的缺点：</h4><ol type="1"><li>ID3没有考虑连续值，对于特征取值为连续值的情况无法适用。</li><li>ID3选用信息增益作为分裂的依据，会更倾向于特征属性值多的作为分裂节点，举个例子：<span class="math inline">\(-1/3*log(1/3)*3\)</span> &gt; <span class="math inline">\(-1/2*log(1/2)*2\)</span>。</li><li>ID3对于缺失值也无法出来，而且更容易过拟合。</li></ol><h4 id="为什么id3倾向于特征属性值偏多的特征">为什么ID3倾向于特征属性值偏多的特征？</h4><p>  信息增益是整个数据集的经验熵与特征a对整个数据集的经验条件熵的差值，信息增益越大即经验条件熵越小 通俗的来讲,信息增益反映的给定一个条件以后不确定性减少的程度(特征A使得数据集的分类不确定性减少的程度) , 肯定是是分得越细的数据集确定性更高,也就是条件熵越小,信息增益越大。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟退火算法</title>
    <link href="/2021/10/30/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2021/10/30/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="模拟退火算法">模拟退火算法</h2><p>  模拟退火算法是上世纪80年代产生的优化算法，应用于在较大空间中寻找问题的最优解，也是解决TSP问题的一大利器。模拟退火是物质从无序（高温）逐渐趋向（降温）于有序（低温/恒温）的过程。因此在模拟退火算法优化的过程中，从始至终是有一个温度贯穿其中的。那温度在优化过程中起到的作用是什么呢？</p><span id="more"></span><h3 id="算法简介">算法简介</h3><p>  针对一个优化问题，存在非常多的解，可以采用模拟退火（sa）算法逐渐的逼近最优解。它的求解过程是：从一个初始解出发，然后进行局部搜索，获得一个新解，是否接受新解由模拟退火来决定，所以sa在其中起到的作用就是是否接受当前这个新的解。</p><p>  sa中包含几个参数:T温度，$$ 降温系数，n迭代次数。n是指在每个温度T下的迭代次数。具体执行流程如下图所示：</p><figure><img src="/images/sa.png" alt="sa" /><figcaption aria-hidden="true">sa</figcaption></figure><p>模拟退火中的T和n控制整个流程的进行，在每个温度T下都要执行n步（即n次迭代），n步执行完成之后，更新T。每次得到新解之后，都要对新解进行判断，是否接受。假设我们的优化目标（衡量新解的方法）为<span class="math inline">\(f(x)\)</span>，我们求解的过程中是优化目标的值越小越好，所以如何来衡量新解与旧解的优劣呢。<strong>若新解优于上一步的解，直接接受，若不优于上一步的解，则有概率的接受</strong>。依据下面的公式：</p><p><span class="math display">\[rand &lt; exp(-(f(x&#39;)-f(x)) / T)\]</span></p><p>来确定新解是否接受。指数函数的图像如下图所示：</p><figure><img src="/images/exp.gif" alt="exp" /><figcaption aria-hidden="true">exp</figcaption></figure><p>当新解比旧解要差时，<span class="math inline">\(-(f(x&#39;)-f(x)) &lt; 0\)</span>，即指数幂值在y轴的左侧，当T值较大时，指数幂值在靠近y轴的左侧部分，即概率值较大，接受较差解的概率要高一些，当随着温度T的下降，指数幂值值也降低，接受差解的概率较小。即模拟退火算法也是在前期可以较高概率的接受差解，从而快速跳出局部最优，随着搜索的进行，温度T逐渐下降，便不容易跳出当前范围。这也有点像深度学习调参的过程，初期学习率lr较大，随着求解过程的进行，学习率lr降低是一样的道理。<strong>若想在后期也以一个较大的概率接受差解，随着温度的降低或迭代次数的进行 可以在分母上乘一个值，提高分母的值，增大概率</strong>。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;GoProject/algorithm/heuristic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFuncRes</span><span class="hljs-params">(x, y <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span>&#123; <span class="hljs-comment">// 目标函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">6.0</span> * math.Pow(x, <span class="hljs-number">7</span>) + <span class="hljs-number">8.0</span> * math.Pow(x, <span class="hljs-number">6</span>)  + <span class="hljs-number">7.0</span> * math.Pow(x, <span class="hljs-number">3</span>) + <span class="hljs-number">5</span> * math.Pow(x, <span class="hljs-number">2</span>) - x*y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimulateAnneal</span><span class="hljs-params">()</span></span> &#123;<br>result := math.MaxFloat64<br>t := <span class="hljs-number">100.0</span><br>minT := <span class="hljs-number">1e-8</span><br>iterNum := <span class="hljs-number">10000</span><br>delta := <span class="hljs-number">0.98</span><br>rand.Seed(<span class="hljs-number">0</span>)<br>x := rand.Float64() * <span class="hljs-number">100</span><br>bestX := x<br>fmt.Println(bestX)<br><br>cnt := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> t &gt; minT &amp;&amp; iterNum &gt;= <span class="hljs-number">0</span> &#123;<br>xNew := x + rand.Float64() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> xNew &gt;= <span class="hljs-number">0</span> &amp;&amp; xNew &lt;= <span class="hljs-number">100</span> &#123;<br>cnt++<br>funcNew := getFuncRes(xNew, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> funcNew &lt; result &#123;<br>x = xNew<br>bestX = x<br>result = funcNew<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p := math.Exp(<span class="hljs-number">-1</span> * (funcNew - result) / t)<br><span class="hljs-keyword">if</span> rand.Float64() &lt; p &#123;<br>x = xNew<br>&#125;<br><span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">//fmt.Println(&quot;prob &quot;, p)</span><br>&#125;<br><br>&#125;<br>&#125;<br>iterNum--<br>t = t * delta<br>&#125;<br>fmt.Println(bestX, result, cnt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LateAcc</span><span class="hljs-params">()</span></span> &#123;<br><br>rand.Seed(<span class="hljs-number">0</span>)<br><br>bestX := rand.Float64() * <span class="hljs-number">100</span><br>bestRes := <span class="hljs-number">0.0</span><br><br>pLa := <span class="hljs-built_in">new</span>(heuristic.LateAcceptance)<br>pLa.Init(<span class="hljs-number">200</span>)<br><br>pIterNum := <span class="hljs-number">10000</span><br>cnt := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> pIterNum &gt; <span class="hljs-number">0</span> &#123;<br>x := bestX + rand.Float64() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">100</span> &#123;<br>cnt++<br>pRes := getFuncRes(x, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> pLa.Accept(pRes) &#123;<br>bestX = x<br>bestRes = pRes<br>&#125;<br>&#125;<br>pIterNum--<br>&#125;<br>fmt.Println(bestX, bestRes, cnt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>SimulateAnneal()<br>LateAcc()<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟退火</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark-使用总结</title>
    <link href="/2021/07/20/Spark-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/20/Spark-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>  在使用spark的过程中经常会遇到一些问题，有的是自己对api不熟悉引起的，还有一些问题是spark本身存在的bug，为了避免在同一个位置摔倒两次，所以要把平时遇到的问题记录下来。其实自己之前积攒了很多问题，想着一一把它记录下来（代码已经有了），可是随着时间的推移，之前的一些问题现在看上去还是自己太过初级了，就一直都没有动笔。Anyway，好记性不如烂笔头，还是要行动起来。</p><span id="more"></span><h3 id="org.apache.spark.sql.analysisexception-resolved-attributes">1、"org.apache.spark.sql.AnalysisException: resolved attribute(s)"</h3><p>  这个问题我还真是遇到了两次，其实它后面还跟着一些报错，"missing column xxx from col1, col2, col3"等，具体的报错我记不太清楚了。<strong>主要问题是</strong>，当两个dataframe df1, df2 join时，比如关联的字段是[a1, a2]，明明关联字段在左右两个表中都存在，但是<strong>关联的时候就是会报错找不到字段</strong>。很奇怪的问题，对df1，df2追本溯源，他们都来自同一张表，经过不同的变换之后，想把df1，df2关联起来时，就会报上面这个错误。</p><h4 id="解决方案">解决方案</h4><p>  解决方案很简单，把关联字段[a1,a2]分别改成别的名字，比如都变成[a11,a22]，这个操作要在df1和df2中都执行一次。然后进行关联即可。</p><blockquote><p>Ref：https://gankrin.org/how-to-fix-spark-error-analysisexception-resolved-attributes/</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作心得总结</title>
    <link href="/2021/07/10/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/10/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="工作经验总结">工作经验总结</h2><h3 id="为什么要写这个总结">为什么要写这个总结</h3><p>  自己工作以来，前期的成长还是比较快的，可以快速的学习技术，业务知识，与人沟通的能力，但是也有几点没有学好，比如：总结的能力，展示汇报的能力，以及表达自己观点的能力...这几点自身感觉是没有明显的提升。可能与我自身的性格、想法有关，仿佛自己一直在觉着只要写好代码，做好工作就行了，最开始还觉着很潇洒，慢慢觉着这样并不好，<strong>一直停留在固有的思维层面，这是比较可怕的</strong>。</p><span id="more"></span><p>  曾经有人对我说，要想成长，要学会适当的跳出当前的层级去思考问题，去考虑更高一点层级的问题，格局要大。说实话我第一次听到这样的话时，感觉有点虚、假，甚至有些pua的意味。可是转念一想，并不是完全没有道理，假如我们一直按照自己的固有思维去考虑问题，我们一直停留在一个水平面。当别人给我们指点时，我们会有恍然大悟的感觉，如果此时我们能反思为什么别人会这样思考，为什么他能想到自己没有想到的一点，如果能得到别人这样思考的原因，我们也就在慢慢向其靠近。</p><p>  工作了两年时间之后，发现自己的成长的确越来越慢，似乎有一点停滞。有时候仿佛被忙碌蒙蔽了双眼，曾经有一段时间特别忙，特别累，但是却在做着重复性的工作，好像一直都没有成长。当忙碌的节奏停了下来，回头一看才发现自己这一段时间只是忙碌，却收获甚少。而身处工作中，忙碌是必不可少的，可是我们要如何在忙碌中成长呢，那就是要不断的总结，也就是我想写这篇博客的原因。不断的把工作中的想法、心得记录下来，督促自己。</p><h3 id="总结ing....">总结ing....</h3><p>1、处理数据时要考虑数据的完整性、正确性，处理完成之后要记得校验。</p><p>2、若要通过做图反应自己产出的数据，要考虑受众范围，比如坐标轴的解释。若数据范围跨度比较大，不能很好的展示细节，是否可以滤除一些异常值，只展示部分范围，把细节展示出来。</p><p>3、与人沟通时，先假设对方的出发点是对我们好，这样二者的立场会先一致，不容易引起矛盾，若不合适，再表达自己的观点也不迟。</p><p>....</p><p>Wo wo wo</p><h3 id="共勉">共勉</h3>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资源均分</title>
    <link href="/2021/06/04/%E8%B5%84%E6%BA%90%E5%9D%87%E5%88%86/"/>
    <url>/2021/06/04/%E8%B5%84%E6%BA%90%E5%9D%87%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="资源均分">资源均分</h2><h2 id="背景">背景</h2><p>  这道题目说实话我目前还不知道最优或者标准的做法是什么，它不像是一些标准的dp、树啊之类的问题。</p><h2 id="题目">题目</h2><p>  假设在中东各个国家都有一定的石油库存，每个国家的库存可能不一样，现在你作为掌管石油的老大，你手中有M吨石油，如何分配石油给这些国家，<strong>让整体的石油分布看上去比较均衡</strong>，你可以分配手中的M吨石油，但是不能在各个国家之间调拨石油。你分配的越好，越不会引起战争。</p><span id="more"></span><p>  这里有两点需要注意，</p><p>1、整体的分布比较均衡，并没有说具体的衡量标准是什么，如何定义均衡需要自己思考。</p><p>2、各个国家之间的石油不能相互调拨，你只能分配手中的M吨石油。</p><p>  这里的看上去均衡，并不是一定要求大家的石油都一样，而是让国家之间的石油分布差异不是很大，若能完全均衡当然是最好。</p><p>我的第一个思路是找到最大的那个国家的石油n，然后计算其它国家与的石油与n的差值，然后从m中分配出一部分石油来弥补这个差值。若最后m依然&gt;0，然后将这部分石油再均分即可。可是发现这个做法有很多边界case是不满足的，当最多的石油与最少的石油差值大于m时，其它国家完全没有分配，这未必是一种均衡方式。</p><p>第二个思路是采用运筹的方式来解决，因为可以动态的去搜索石油的分布，根据我们定义的score来衡量是否均衡，是否接受当前的搜索结果。同时也可以根据我们最大与最小的差值来分配两者之间的石油（此处分配是保证每个国家的石油&gt;=最初的状态，所以不属于国家之间的调拨），让最大与最小的差值不断缩小，趋向于均衡。</p><h3 id="score如何定义">score如何定义</h3><p>  此处我是定义了两部分score，第一部分是任意两个国家之间的石油差值，第二部分是每个国家的石油与平均值的差值。两个score相加作为最终的score，整体的score越小表示分布的相对均衡。</p><h3 id="算法如何设计">算法如何设计</h3><p>  我考虑采用模拟退火来作为是否接受新解，若新解满足接受条件，则接受新解，若优于当前最优解，则更新最优解。温度降到最小值之后则停止搜索，返回结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></div></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> r = rand.New(rand.NewSource(<span class="hljs-number">0</span>)) <span class="hljs-comment">// 用于搜索</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> -num<br>&#125;<br><span class="hljs-keyword">return</span> num<br>&#125;<br><br><span class="hljs-comment">// 计算score</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateScore</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>sum += nums[i]<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>res += abs(nums[j] - nums[i])<br>&#125;<br>&#125;<br>sum /= <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>res += abs(sum - nums[i])<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, m <span class="hljs-keyword">int</span>)</span></span> &#123;<br>T, minT, ratio := <span class="hljs-number">100.0</span>, <span class="hljs-number">0.0001</span>, <span class="hljs-number">0.99</span> <span class="hljs-comment">// 初始化最高温度，最低温度，降温速率</span><br><br>tmp := <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, nums...)<br>fix := initial(<span class="hljs-built_in">len</span>(nums), m) <span class="hljs-comment">// 将m分配完成</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>tmp[i] += fix[i]<br>&#125;<br>s1 := calculateScore(tmp)          <span class="hljs-comment">// 计算score</span><br>bestNum := <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, tmp...) <span class="hljs-comment">// 存储最优解</span><br>fmt.Println(bestNum)<br><br><span class="hljs-keyword">for</span> T &gt; minT &#123;<br>iter := <span class="hljs-number">500</span><br><span class="hljs-keyword">for</span> iter &gt; <span class="hljs-number">0</span> &#123;<br>pre := <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, tmp...)<br><br>localSearch(nums, pre) <span class="hljs-comment">// 搜索</span><br>s2 := calculateScore(pre)<br><span class="hljs-keyword">if</span> s2 &lt; s1 &#123; <span class="hljs-comment">// 若新解优于最优解，直接接受</span><br>bestNum = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, pre...)<br>tmp, s1 = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, pre...), s2<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> math.Exp(-<span class="hljs-keyword">float64</span>(s2-s1)/T) &lt; r.Float64() &#123; <span class="hljs-comment">// 有概率接受</span><br>tmp, s1 = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, pre...), s2<br>&#125;<br>iter--<br>&#125;<br>T *= ratio<br>&#125;<br><span class="hljs-comment">//nums = bestNum  不会生效</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>nums[i] = bestNum[i]<br>&#125;<br>fmt.Println(bestNum)<br>&#125;<br><br><span class="hljs-comment">// 初始化 参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initial</span><span class="hljs-params">(cnt, m <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cnt<span class="hljs-number">-1</span>; i++ &#123;<br>num := r.Intn(m)<br>m -= num<br>res = <span class="hljs-built_in">append</span>(res, num)<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, m)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMaxMin</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>min, max := <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-number">32</span><br>ind1, ind2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> ind, num := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> num &gt; max &#123;<br>max, ind2 = num, ind<br>&#125;<br><span class="hljs-keyword">if</span> num &lt; min &#123;<br>min, ind1 = num, ind<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ind1, ind2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">localSearch</span><span class="hljs-params">(nums, tmp []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>minInd, maxInd := findMaxMin(tmp)<br><span class="hljs-keyword">if</span> nums[minInd] &gt; tmp[minInd] || nums[maxInd] &gt; tmp[maxInd] &#123;<br>tmp = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, nums...)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> tmp[maxInd] &gt; nums[maxInd] &#123; <span class="hljs-comment">// 防止r.Intn() 报错</span><br>m := r.Intn(tmp[maxInd] - nums[maxInd])<br>tmp[minInd] += m<br>tmp[maxInd] -= m<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>sum += nums[i]<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">50</span>&#125;<br>m := <span class="hljs-number">200</span><br>sum := m + calculateSum(nums)<br>fmt.Println(nums, sum)<br><br>dispatch(nums, m)<br>fmt.Println(nums, calculateSum(nums))<br>&#125;<br><br>-------------------<br>[<span class="hljs-number">1</span> <span class="hljs-number">200</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">50</span>] <span class="hljs-number">458</span>  初始值<br>[<span class="hljs-number">75</span> <span class="hljs-number">272</span> <span class="hljs-number">16</span> <span class="hljs-number">28</span> <span class="hljs-number">67</span>]<br>[<span class="hljs-number">75</span> <span class="hljs-number">201</span> <span class="hljs-number">55</span> <span class="hljs-number">60</span> <span class="hljs-number">67</span>]<br>[<span class="hljs-number">75</span> <span class="hljs-number">201</span> <span class="hljs-number">55</span> <span class="hljs-number">60</span> <span class="hljs-number">67</span>] <span class="hljs-number">458</span> 最终分配结果<br><br></code></pre></td></tr></table></figure><h3 id="todo">todo</h3><p>1、score的定义未必合理，可以考虑再使用更优的score，比如每个国家的涨幅。。。</p><p>2、搜索方式也可以更丰富些。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源均分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prim算法</title>
    <link href="/2021/04/11/Prim%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/11/Prim%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="prim算法">Prim算法</h2><p>  假定我们要给各个村子修路，将村子之间互相连通起来，但是呢又不想直在任意两两村子之间直接修，那样会浪费成本。因此我们可以考虑在部分村子之间修，只要保证这些路可以将所有的村子连通起来就好（即村A和村B之间没有直接连通，但是可以通过村C来中转，从A-C-B）。也就是说<strong>我们有N个村子，我们可以修N-1条路，来保证村之间可以有路连通</strong>。也称为最小生成树（最小支撑树），即保持"连通性"的前提下的最小子图，子图各个边的权重之和最小。</p><span id="more"></span><h2 id="解决方案">解决方案</h2><h3 id="贪心法">贪心法</h3><p>  我们设定无向图G=(P, E)为连通图，P为G中的所有顶点，E为顶点之间的边。我们要从中筛选出部分边构成最小生成树，使的边权重之和最小。</p><p>我们定义V为已经修好路的顶点，U为还未进行修路的顶点，V中的顶点构成了最小生成树后的子树，U中的点会逐个进入V中，最终生成一个最小生成树。</p><p>1、首先我们将第一个顶点放入V中，并将其从U中删除。</p><p>2、从U中选择一个距离V最近的顶点<span class="math inline">\(u_k\)</span>，即从U中选择一个顶点，它距离V中所有点的最短距离，是U中的顶点的最小的。</p><p>3、将<span class="math inline">\(u_k\)</span>从U中删除，加入V中。</p><p>4、以此类推，直到U中为空，即得到了最小生成树的权重。</p><h2 id="代码逻辑">代码逻辑</h2><p>  第一种写法，我们首先将第一个顶点加入V中，然后开始尝试m-1次，将剩下的顶点依次纳入V中。重点在于如何求U中距离V最近的顶点，我们这里直接两层循环，遍历U中顶点，计算其与V中所有顶点的最短距离，保存距离最短的U中的顶点的索引。遍历结束，索引对应的U中顶点加入到V中即可。时间复杂度为<span class="math inline">\(O(n^3)\)</span></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prim</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>  m := <span class="hljs-built_in">len</span>(matrix)<br>  V := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>  <span class="hljs-keyword">var</span> U []<span class="hljs-keyword">int</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>    U = <span class="hljs-built_in">append</span>(U, i)<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; m<span class="hljs-number">-1</span>; k++ &#123;<br>    min := <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>    ind1, ind2 := <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> V &#123;<br>      <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> U &#123;<br>        <span class="hljs-keyword">if</span> matrix[V[i]][U[j]] &lt; min &#123;<br>          min = matrix[V[i]][U[j]]<br>          ind1, ind2 = i, j<br>        &#125;<br>      &#125;<br>    &#125;<br>    fmt.Println(V[ind1], U[ind2], min)<br>    V = <span class="hljs-built_in">append</span>(V, U[ind2])<br>    U = <span class="hljs-built_in">append</span>(U[:ind2], U[ind2+<span class="hljs-number">1</span>:]...)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  matrix := [][]<span class="hljs-keyword">int</span>&#123;<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">128</span>&#125;,<br>    &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">3</span>, <span class="hljs-number">128</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;,<br>  &#125;<br>  prim(matrix)<br>  fmt.Println()<br>  prim1(matrix)<br>&#125;<br></code></pre></td></tr></table></figure><p>  上面那种写法的时间复杂度比较高，我们可以考虑进行下优化。在找距离V最近的顶点时，是存在优化空间的。不需要每次都遍历V和U，我们可以用一个数组记录下U中顶点到V的最短距离。</p><p>1、dis数组的长度为顶点的个数，当V中只有第一个顶点<span class="math inline">\(v_0\)</span>，dis中记录了该顶点与U中所有顶点的最近距离（无向图，a-&gt;b = b-&gt;a）。</p><p>2、当V中新增一个顶点<span class="math inline">\(v_1\)</span>时，我们可以对dis进行一次更新。若U中存在顶点<span class="math inline">\(u_k\)</span>其距离<span class="math inline">\(v_1\)</span>的值小于其距离<span class="math inline">\(v_0\)</span>的值，我们就可以更新dis中的信息。</p><p>3、直接根据dis中的距离来计算距离V最近顶点即可。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prim1</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>m := <span class="hljs-built_in">len</span>(matrix)<br>dis := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>dis[i] = matrix[<span class="hljs-number">0</span>][i]<br>&#125;<br>status := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>, m)<br><br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m<span class="hljs-number">-1</span>; i++ &#123; <span class="hljs-comment">// 需要找剩余的点</span><br>t := <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123; <span class="hljs-comment">// 每次遍历剩余的所有点</span><br><span class="hljs-keyword">if</span> !status[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j]) &#123;<br>t = j<br>&#125;<br>&#125;<br>res += dis[t]<br>fmt.Println(i, t, dis[t])<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123;<br><span class="hljs-keyword">if</span> matrix[t][j] &lt; dis[j] &#123;<br>dis[j] = matrix[t][j]<br>&#125;<br>&#125;<br>status[t] = <span class="hljs-literal">true</span><br>&#125;<br>fmt.Println(res)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>matrix := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">128</span>&#125;,<br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">128</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br>prim(matrix)<br>fmt.Println()<br>prim1(matrix)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floyd算法</title>
    <link href="/2021/04/11/Floyd%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/11/Floyd%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="floyd-算法">Floyd 算法</h2><p>  Floyd算法也是求最短路径的一种算法，主要用于计算两两节点之间最短的距离。不像dijstra是固定一个起点，在Floyd中每一个点都可以是起点，用来计算它到其它节点之间的最短距离。其实Floyd就像是执行了n次dijstra算法。</p><span id="more"></span><h2 id="算法描述">算法描述</h2><p>  给定一个带权重的图G=(V,E)，可以存在负权(但不能存在负权环路)。V代表顶点的集合，E代表顶点之间的权重。</p><p>我们要计算任意两个顶点之间最短距离。</p><p>1、<strong>例如：AB两个顶点之间的最短距离不一定是A直接到B的距离，有可能是A经过C之后再去B得到的最短距离</strong>。</p><p>2、我们可以称C为AB的媒介，那怎样去找这些媒介呢？</p><p>3、<strong>遍历</strong>，没错就是遍历其它点，若存在一个媒介可以是Dis(A, C) + Dis(C, B) &lt; Dis(A, B)，则我们就可以更新Dis(A, B)=Dis(A, C) + Dis(C, B)。最终遍历完一遍，我们就能知道AB之间的最短距离了。</p><p>4、因此，<strong>我们在计算的过程中可以不断的更新两个点之间的最短距离</strong>。</p><h2 id="代码逻辑">代码逻辑</h2><p>   代码很好理解，就是<strong>三重循环</strong>，最外层表示媒介，里面两层表示两个端点。同时我们用tPath这个变量记录任意两点之间最短距离经过的路径，若两点之间不存在媒介，则<span class="math inline">\(tPath[i][j]=-1\)</span>，表示二者之间直接连接就是最短路径。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-comment">//https://juejin.im/post/5cc79c93f265da035b61a42e</span><br><br><span class="hljs-keyword">type</span> Floyd <span class="hljs-keyword">struct</span> &#123;<br>tTwoPointDis [][]<span class="hljs-keyword">int</span><br>tPath        [][]<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Floyd)</span> <span class="hljs-title">Init</span><span class="hljs-params">(tDis [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>f.tTwoPointDis = tDis<br><br>r := <span class="hljs-built_in">len</span>(tDis)<br><br>f.tPath = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, r)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f.tPath &#123;<br>f.tPath[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, r)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; r; j++ &#123;<br>f.tPath[i][j] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Floyd)</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;before&quot;</span>)<br><span class="hljs-keyword">for</span> _, tNums := <span class="hljs-keyword">range</span> f.tTwoPointDis &#123;<br><span class="hljs-keyword">for</span> _, tNum := <span class="hljs-keyword">range</span> tNums &#123;<br>fmt.Print(tNum, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br>r := <span class="hljs-built_in">len</span>(f.tTwoPointDis)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; r; k++ &#123; <span class="hljs-comment">// 媒介</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; r; j++ &#123;<br><span class="hljs-keyword">if</span> f.tTwoPointDis[i][j] &gt; (f.tTwoPointDis[i][k] + f.tTwoPointDis[k][j]) &#123;<br>f.tPath[i][j] = k <span class="hljs-comment">// 记录媒介</span><br>f.tTwoPointDis[i][j] = f.tTwoPointDis[i][k] + f.tTwoPointDis[k][j]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;after&quot;</span>)<br><span class="hljs-keyword">for</span> _, tNums := <span class="hljs-keyword">range</span> f.tTwoPointDis &#123;<br><span class="hljs-keyword">for</span> _, tNum := <span class="hljs-keyword">range</span> tNums &#123;<br>fmt.Print(tNum, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; r; j++ &#123;<br><span class="hljs-keyword">if</span> i != j &#123;<br>fmt.Println(f.getPath(i, j))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Floyd)</span> <span class="hljs-title">getPath</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-comment">// 打印路径</span><br><span class="hljs-keyword">if</span> f.tPath[i][j] == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span> + strconv.Itoa(i) + <span class="hljs-string">&quot; &quot;</span> + strconv.Itoa(j)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>k := f.tPath[i][j]<br><span class="hljs-keyword">return</span> f.getPath(i, k) + f.getPath(k, j)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tDis := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">127</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">127</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>&#125;&#125;<br><br>f := <span class="hljs-built_in">new</span>(Floyd)<br>f.Init(tDis)<br>f.solve()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>  ok，这就是floyd算法，我们不能被它的名字给吓住了。其实就是利用三重循环，计算图中任意两点的最短距离。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排课程</title>
    <link href="/2021/01/10/%E6%8E%92%E8%AF%BE%E7%A8%8B/"/>
    <url>/2021/01/10/%E6%8E%92%E8%AF%BE%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="排课程">排课程</h2><p>  Leetcode上有这样一道题，给定N个课程，但是有的课再学习之前，需要先学完别的某一个课程。就像我们在大学里面学专业之前要先学会高数才行。</p><p>  题目链接 <a href="https://leetcode.com/problems/course-schedule/">https://leetcode.com/problems/course-schedule/</a>，描述如下：</p><p>  There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses-1</code>.</p><span id="more"></span><p>  Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>  Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p>如上面的描述，给定课程数N，以及prerequisites [[0, 1]]，表示我们在学课程0之前要先把课程1学了，请我们计算最终是否能学完全部的课程。</p><p>整个问题梳理一下就是我们要先学一部分课程，然后再去学另一部分课程。但是存在一些<strong>特例</strong>，假如requisites=[[0, 1], [1, 0]]，第一个表示我们在学课程0之前要把课程1学完，第二个表示我们在学课程1之前把课程0学完。这样就形成了<strong>循环依赖</strong>，不能学完所有的课程。</p><p>  最初我的想法是构建链表，即利用链表构建每一个门课程之间的关系，但是链表是一一连接的，而课程之间可以存在一对多连接，比如学完课程1我可以学课程2 3，[[2,1],[3,1]]这种情况。因此我们就不能用链表来表示这种结构，后来看到网友的提示可以用图来表示。因此考虑用图来表示，我们将每一门课程表示一个顶点，若某课程B需要先学课程A才可以学，则在AB之间连接一条线，同时记录该课程B的<strong>连接数(出度)</strong>，我们要优先处理那些<strong>出度为0</strong>(不需要依赖其它课程)的课程，学完出度为0的课程之后，对于那些与其连接的课程<strong>出度要减一</strong>，表示我所依赖的课程数少了一个，若当前所依赖的课程为0，则将该课程加入待学的课程队列。最后，若仍然存在出度不为0的课程，表示不可以完成这些课，所所有的课程出度都为0，则可以完成这些课程。BFS的做法：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>graph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(prerequisites)) <span class="hljs-comment">// 建立图 </span><br>in := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)  <span class="hljs-comment">// 记录出度</span><br><span class="hljs-keyword">var</span> queue []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> prerequisites &#123;<br>graph[a[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(graph[a[<span class="hljs-number">1</span>]], a[<span class="hljs-number">0</span>]) <span class="hljs-comment">// key为先学的课程</span><br>in[a[<span class="hljs-number">0</span>]]++<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123; <span class="hljs-comment">// 出度为0的课程加入队列</span><br><span class="hljs-keyword">if</span> in[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>front := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[front] &#123; <span class="hljs-comment">// 与其相关课程的出度减一</span><br>in[next]--<br><span class="hljs-keyword">if</span> in[next] == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 若出度为0，加入队列</span><br>queue = <span class="hljs-built_in">append</span>(queue, next)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, pre := <span class="hljs-keyword">range</span> in &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>numCourses := <span class="hljs-number">2</span><br>prerequisite := [][]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;<br>fmt.Println(canFinish(numCourses, prerequisite))<br>&#125;<br></code></pre></td></tr></table></figure><p>此题还有一个延伸，若能学完所有的课程，返回课程的学习顺序。<a href="https://leetcode.com/problems/course-schedule-ii/">https://leetcode.com/problems/course-schedule-ii/</a>，其实我们只需要在上面的for循环中，没出现一个出度为0的课程，将其加入到结果中即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>&#125;<br><br>graph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(prerequisites))<br>in := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)<br><span class="hljs-keyword">for</span> _, pre := <span class="hljs-keyword">range</span> prerequisites &#123;<br>graph[pre[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(graph[pre[<span class="hljs-number">1</span>]], pre[<span class="hljs-number">0</span>])<br>in[pre[<span class="hljs-number">0</span>]]++<br>&#125;<br><br><span class="hljs-keyword">var</span> queue []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> in[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>front := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br>res = <span class="hljs-built_in">append</span>(res, front) <span class="hljs-comment">// 将课程编号加入到结果中</span><br><span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[front] &#123;<br>in[next]--<br><span class="hljs-keyword">if</span> in[next] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, next)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == numCourses &#123;<br><span class="hljs-keyword">return</span> res<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外还有一种基于DFS的做法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder1</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>&#125;<br><br>graph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(prerequisites))<br><span class="hljs-keyword">for</span> _, pre := <span class="hljs-keyword">range</span> prerequisites &#123;<br>graph[pre[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">append</span>(graph[pre[<span class="hljs-number">0</span>]], pre[<span class="hljs-number">1</span>]) <span class="hljs-comment">// key为后学的课程</span><br>&#125;<br>visited := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)<br><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> !dfsFindOrder(graph, &amp;visited, i, &amp;res) &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfsFindOrder</span><span class="hljs-params">(graph <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, visited *[]<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>, res *[]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> (*visited)[i] == <span class="hljs-number">0</span> &#123;<br>(*visited)[i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(graph[i]); k++ &#123;<br><span class="hljs-keyword">if</span> !dfsFindOrder(graph, visited, graph[i][k], res) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>(*visited)[i] = <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*visited)[i] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>*res = <span class="hljs-built_in">append</span>(*res, i)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>numCourse := <span class="hljs-number">4</span><br>prerequisites := [][]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;&#125;<br>fmt.Println(findOrder(numCourse, prerequisites))<br>fmt.Println(findOrder1(numCourse, prerequisites))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述的做法是基于DFS，首先还是建立一个图，然后利用visited记录每一个课程的状态，0:未学，1:正在学，2:学完。DFS的图和BFS的图不一样，graph中的key是不同的。在BFS中key是要先学的课程，DFS中的key是要后学的课程。DFS的做法，有一种倒序DFS的意思，即遍历每一门课程，若该课程的状态是0，则先置为1，然后去找它所依赖的其它课程，若依赖的课程为0，则置为1，继续向前找，找到所有依赖的课程都是未学，则表示这条路是可行的，至少没有循环依赖，则把这些课全部置为2已学。若先前着的过程中某个课是学完的，则表示这条路也是可行的，继续找其它分支的依赖的课程，若都是学完的，则把这条路经过的课程置为2已学。若向前找的过程中某个课程是正在学的，表示存在循环依赖，不可行，直接返回。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alogithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>延迟接受算法</title>
    <link href="/2020/07/18/%E5%BB%B6%E8%BF%9F%E6%8E%A5%E5%8F%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/18/%E5%BB%B6%E8%BF%9F%E6%8E%A5%E5%8F%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="延迟接受算法">延迟接受算法</h2><p>  延迟接受算法是一个比较经典的优化算法，也叫做盖尔-沙普利算法，是盖尔和沙普利为了寻找一个稳定<a href="https://baike.baidu.com/item/匹配/6397551">匹配</a>而设计出的市场机制。从算法的角度来讲，延迟接受就是对当前解不会立即接受，而是暂时的不被拒绝，当迭代次数停止以后，会从手上选择最优的那一个作为最终解。</p><span id="more"></span><h2 id="问题描述">问题描述</h2><p>  我们有一个要优化的目标<span class="math inline">\(f(x,y,z)=x^2 \ast z-y^3 \ast z^2+x^2 \ast y^3-x/y\)</span>，<span class="math inline">\(x,y,z\)</span>的范围都是[0, 100]，我们就要在这个范围内求出函数<span class="math inline">\(f(x,y,z)\)</span>的最小值。由于解空间比较大，我们无法在常数时间内取得最优解，所以只能考虑启发式的方式来寻求局部最优解。<strong>启发式</strong>方法可以简单的理解为我们给定一个初始解，然后在该初始解的邻域范围内进行搜索，最终获得一个局部最优解(全局最优解)。<strong>延迟接受</strong>就是一种求解方法。</p><h2 id="算法描述">算法描述</h2><p>  延迟接受算法就是将当前的新解与<span class="math inline">\(n\)</span>步之前的解进行对比，若当前解优于<span class="math inline">\(n\)</span>步以前的解，则直接接受当前解，若比<span class="math inline">\(n\)</span>步之前的解差，则拒绝当前解。</p><p>  延迟接受还有一个变种，就是带爬山的延迟接受( Late Acceptance Hill-Climbing)，从名字上也可以看出，“带爬上”其实就是引入了爬上的思路，即当前解与上一步的解来比较，若优于上一步解，则直接接受新解，否则拒绝。</p><figure><img src="/images/lahc.jpg" alt="lahc" /><figcaption aria-hidden="true">lahc</figcaption></figure><p>延迟接受算法的流程如上图所示，</p><p>1、<span class="math inline">\(s\)</span>为初始解，<span class="math inline">\(C\left(s\right)\)</span>为初始解的函数值，<span class="math inline">\(Lfa\)</span>就是延迟接受的步长，我们可以以一个队列或者数组来存储延迟接受的<span class="math inline">\(Lfa\)</span>个解，初始解都为<span class="math inline">\(C(s)\)</span>。</p><p>2、开始迭代，构建新解<span class="math inline">\(s\ast\)</span>，计算新解的函数值<span class="math inline">\(C(s\ast)\)</span>。</p><p>3、计算<span class="math inline">\(Lfa\)</span>步之前的解的函数值<span class="math inline">\(f(v)\)</span>，<span class="math inline">\(v := I \% Lfa\)</span>，<span class="math inline">\(v\)</span>相对于<span class="math inline">\(I\)</span>就是<span class="math inline">\(Lfa\)</span>步之前解的函数值。</p><p>4、比较 <span class="math inline">\(C(s\ast)\)</span> 和 <span class="math inline">\(f(v)\)</span>，比较 <span class="math inline">\(C(s*)\)</span> 和 <span class="math inline">\(C(s)\)</span>，若<span class="math inline">\(C(s\ast)\)</span>优于<span class="math inline">\(f(v)\)</span>或者<span class="math inline">\(C(s)\)</span>，则直接接受当前新解<span class="math inline">\(s\ast\)</span>，并更新<span class="math inline">\(f(v)=C(s\ast)\)</span>。</p><p>5、若<span class="math inline">\(C(s*)\)</span> 差于<span class="math inline">\(f(v)\)</span> 或者 <span class="math inline">\(C(s)\)</span>，则更新 <span class="math inline">\(f(v)=C(s)\)</span>。</p><p>6、I=I+1，直到迭代终止。</p><p>上面就是延迟接受的整个流程，最关键的是第4和第5步，尤其第5步，当前新解比之前n步的解或者上一步的解要差时，应该是将上一步的解重新更新到n步之前的位置。</p><h2 id="算法应用">算法应用</h2><p>  我们可以将延迟接受算法应用到TSP问题中，TSP问题也是一个NP-hard问题，可以采用启发式算法的方式去进行求解。</p><p>部分代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> algorithm<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;TSP/ioinfo&quot;</span><br><span class="hljs-string">&quot;TSP/util&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> LateAcceptance <span class="hljs-keyword">struct</span> &#123;<br>n       <span class="hljs-keyword">int</span><br>tScore []<span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LateAcceptance)</span> <span class="hljs-title">Init</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, pStartScore <span class="hljs-keyword">float64</span>)</span></span> &#123;<br>l.n = n + <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l.n; i++ &#123;<br>l.tScore = <span class="hljs-built_in">append</span>(l.tScore, pStartScore)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LateAcceptance)</span> <span class="hljs-title">Accept</span><span class="hljs-params">(pScore <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">var</span> pAccept <span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">if</span> pScore &lt;= l.tScore[<span class="hljs-number">0</span>] &#123;<br>pAccept = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pScore &lt;= l.tScore[<span class="hljs-built_in">len</span>(l.tScore) - <span class="hljs-number">1</span>] &#123;<br>pAccept = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pAccept = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> pAccept &#123;<br>l.tScore = <span class="hljs-built_in">append</span>(l.tScore, pScore)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l.tScore = <span class="hljs-built_in">append</span>(l.tScore, l.tScore[<span class="hljs-built_in">len</span>(l.tScore) - <span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l.tScore) &gt;= l.n &#123;<br>l.tScore = l.tScore[<span class="hljs-number">1</span>:]<br>&#125;<br><br><span class="hljs-keyword">return</span> pAccept<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changCity1</span><span class="hljs-params">(dataSrc []ioinfo.Data, R1 rand.Rand)</span> []<span class="hljs-title">ioinfo</span>.<span class="hljs-title">Data</span></span> &#123;<br>pos1 := R1.Intn(<span class="hljs-built_in">len</span>(dataSrc)<span class="hljs-number">-3</span>) + <span class="hljs-number">1</span><br>pos2 := R1.Intn(<span class="hljs-built_in">len</span>(dataSrc)-pos1<span class="hljs-number">-1</span>) + pos1<br>dataDest := <span class="hljs-built_in">make</span>([]ioinfo.Data, <span class="hljs-built_in">len</span>(dataSrc))<br><span class="hljs-built_in">copy</span>(dataDest, dataSrc)<br>r := R1.Intn(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> pos1 &lt; pos2 &#123;<br>dataDest[pos1], dataDest[pos2] = dataDest[pos2], dataDest[pos1]<br>pos1 ++<br>pos2 --<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dataDest[pos1], dataDest[pos2] = dataDest[pos2], dataDest[pos1]<br>&#125;<br><br><span class="hljs-keyword">return</span> dataDest<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">La</span><span class="hljs-params">(pFileName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>data := util.GetSampleData(pFileName, <span class="hljs-literal">false</span>)<br>r := util.GetResult(data)<br><br>pLa := <span class="hljs-built_in">new</span>(LateAcceptance)<br>pLa.Init(<span class="hljs-number">215</span>, r)<br><br><span class="hljs-keyword">var</span> R1 = rand.New(rand.NewSource(<span class="hljs-number">0</span>))<br><br>s1 := time.Now().UnixNano()<br>pIterNum := <span class="hljs-number">200000</span><br><span class="hljs-keyword">for</span> pIterNum &gt; <span class="hljs-number">0</span> &#123;<br>temp := changCity1(data, *R1)<br>rn := util.GetResult(temp)  <span class="hljs-comment">// 计算当前解的里程 </span><br><span class="hljs-keyword">if</span> pLa.Accept(rn) &#123;<br>data = temp<br>&#125;<br>pIterNum--<br>&#125;<br>s2 := time.Now().UnixNano()<br>fmt.Println(data, s2 -s1)<br><span class="hljs-keyword">return</span> util.GetResult(data)<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">延迟接受启动：<br>[ 1 -&gt; 43 -&gt; 23 -&gt; 56 -&gt; 41 -&gt; 42 -&gt; 64 -&gt; 61 -&gt; 69 -&gt; 36 -&gt; 37 -&gt; 71 -&gt; 60 -&gt; 70 -&gt; 20 -&gt; 15 -&gt; 57 -&gt; 27 -&gt; 52 -&gt; 13 -&gt; 54 -&gt; 19 -&gt; 59 -&gt; 14 -&gt; 53 -&gt; 11 -&gt; 66 -&gt; 65 -&gt; 38 -&gt; 31 -&gt; 10 -&gt; 58 -&gt; 72 -&gt; 39 -&gt;  9 -&gt; 40 -&gt; 12 -&gt; 17 -&gt; 76 -&gt; 26 -&gt;  7 -&gt; 35 -&gt;  8 -&gt; 46 -&gt; 34 -&gt; 67 -&gt; 75 -&gt;  4 -&gt; 45 -&gt; 29 -&gt;  5 -&gt; 48 -&gt; 47 -&gt; 21 -&gt; 74 -&gt; 30 -&gt;  2 -&gt; 68 -&gt;  6 -&gt; 51 -&gt;  3 -&gt; 44 -&gt; 32 -&gt; 50 -&gt; 25 -&gt; 55 -&gt; 18 -&gt; 24 -&gt; 49 -&gt; 16 -&gt; 63 -&gt; 33 -&gt; 73 -&gt; 62 -&gt; 28 -&gt; 22 -&gt;  1 -&gt;] 170124000ns<br>588.1953208548182<br><br></code></pre></td></tr></table></figure><p>76个点需要170ms，最终结果588.195</p><p>全局最优解为545.3875524687445，延迟接受的解比全局最优解差7%左右，结果还是可以接受的。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>late acceptance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dijkstra算法</title>
    <link href="/2020/07/05/dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/05/dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="dijkstra算法">Dijkstra算法</h2><p>  中文名又叫迪杰斯特拉算法，是一种单源最短路径算法，用于计算一个节点到其它所有节点的最短路径。通俗的讲就是确定好一个起点之后，计算起点到其它点最短路径。常用于一些路由计算或者路径规划等场景。</p><span id="more"></span><h2 id="算法描述">算法描述</h2><p>  给定一个带权有向图G=(V, E)，V代表顶点集合，E代表顶点之间的权重。</p><p>1、把顶点分成两个集合S、U，S代表已经获得最短路径的顶点，起初只有源点一个，U代表未加入路径的顶点。（保持源点s到S中各个顶点的最短路径长度不大于源点s到U中各个顶点的最短路径长度）</p><p>2、从U中选出一个顶点k，是从源点到U中所有顶点距离最短的一个，将k加入S，并从U中移除顶点k</p><p>3、根据S中现有的顶点，更新s到U中各个顶点的距离，比如之前s-&gt;m的距离是无穷大，现在经过（s-&gt;k） + （k-&gt;m）为常数值。</p><p>4、重复2、3两步，直到U中的顶点为空</p><h2 id="代码逻辑">代码逻辑</h2><p>  整体的代码逻辑也很简单，首先我们需要两个列表，一个表示访问过的点S一个表示未访问过的点U。一个map path 用于存储从源点到已访问过点的路径。然后我们每次只需要计算从源点s经过S中的某个/某些点之后 到 U中各个点的距离，只需要找出到U中距离最短的点即可。我们可以把S中最后一个经过的点称之为pre，U中访问的点为next，找到路径最短的next之后，我们将next移动到S中。并且源点s到next的路径只是在源点s到pre的基础上加了个u，将s-&gt;u的路径加入到path中即可。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// https://github.com/muzixing/graph_algorithm/blob/master/dijkstra.py</span><br><br><span class="hljs-keyword">const</span>(<br>MaxDis  <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span><span class="hljs-number">-1</span><br>)<br><br><span class="hljs-keyword">type</span> Dijkstra <span class="hljs-keyword">struct</span> &#123;<br>tPints  []<span class="hljs-keyword">string</span><br>tTwoPointDis <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dijkstra)</span> <span class="hljs-title">Init</span><span class="hljs-params">(tPoints []<span class="hljs-keyword">string</span>, tDis [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tPoints) != <span class="hljs-built_in">len</span>(tDis) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;点数与矩阵的大小不一致&quot;</span>)<br>&#125;<br>d.tTwoPointDis = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tPoints); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(tPoints); j++ &#123;<br>key := tPoints[i] + <span class="hljs-string">&quot;_&quot;</span> + tPoints[j]<br>d.tTwoPointDis[key] = tDis[i][j]<br>&#125;<br>&#125;<br>d.tPints = tPoints<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dijkstra)</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span> &#123;<br>tPoints := d.tPints[<span class="hljs-number">1</span>:]                  <span class="hljs-comment">// 未访问过的点</span><br>visited := []<span class="hljs-keyword">string</span>&#123;d.tPints[<span class="hljs-number">0</span>]&#125;         <span class="hljs-comment">// 访问过的点</span><br>src := d.tPints[<span class="hljs-number">0</span>]                       <span class="hljs-comment">// 起点</span><br>pre, next := src, src<br><br>path := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)     <span class="hljs-comment">// 起点到其它点的路径</span><br>path[src + <span class="hljs-string">&quot;_&quot;</span> + src] = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>&#125;<br><br>distanceGraph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 起点到其它点的距离</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(tPoints) &gt; <span class="hljs-number">0</span> &#123;<br>distance := MaxDis<br><span class="hljs-keyword">var</span> ind <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> dst <span class="hljs-keyword">string</span><br><br><span class="hljs-keyword">var</span> nextInd <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> visited &#123;<br><span class="hljs-keyword">for</span> ind, dst = <span class="hljs-keyword">range</span> tPoints &#123;<br>newDis := d.tTwoPointDis[src + <span class="hljs-string">&quot;_&quot;</span> + v] + d.tTwoPointDis[v + <span class="hljs-string">&quot;_&quot;</span> + dst]  <span class="hljs-comment">// 从起点src到已访问过的点v + 从v到未访问过点的距离</span><br><span class="hljs-keyword">if</span> newDis &lt; distance &#123;<br>distance = newDis<br>pre = v<br>next = dst<br>nextInd = ind<br>d.tTwoPointDis[src + <span class="hljs-string">&quot;_&quot;</span> + dst] = distance<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> _, tPoint := <span class="hljs-keyword">range</span> path[src + <span class="hljs-string">&quot;_&quot;</span> + pre] &#123;<br>path[src + <span class="hljs-string">&quot;_&quot;</span> + next] = <span class="hljs-built_in">append</span>(path[src + <span class="hljs-string">&quot;_&quot;</span> + next], tPoint)<br>&#125;<br>path[src + <span class="hljs-string">&quot;_&quot;</span> + next] = <span class="hljs-built_in">append</span>(path[src + <span class="hljs-string">&quot;_&quot;</span> + next], next)  <span class="hljs-comment">// 记录从src到next需经过的路径</span><br><br>distanceGraph[src + <span class="hljs-string">&quot;_&quot;</span> + next] = distance                     <span class="hljs-comment">// 记录从src到next的距离</span><br><br>visited = <span class="hljs-built_in">append</span>(visited, next)<br>tPoints = <span class="hljs-built_in">append</span>(tPoints[:nextInd], tPoints[nextInd+<span class="hljs-number">1</span>:]...)<br>&#125;<br><br>fmt.Println(path)<br>fmt.Println(distanceGraph)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := <span class="hljs-built_in">new</span>(Dijkstra)<br>tPoints := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;<br>tDis := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>,      <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">127</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">127</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>&#125;&#125;<br><br>d.Init(tPoints, tDis)<br>d.dijkstra()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>  Ok，整体的代码逻辑就是这样的，从最初不了解dijkstra算法，到了解用代码实现之后，发现其中的逻辑不算复杂。只要我们能够理解S U两个列表，以及中间状态的存储path，还有如何从U中获得下一个要访问的点。整个问题就解决了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive/SQL日常总结</title>
    <link href="/2020/05/16/Hive-SQL%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/16/Hive-SQL%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="hivesql日常总结">Hive/SQL日常总结</h1><p>  说来惭愧，工作了有一段时间了，才开始接触SQL。自己之前从来没有和SQL打过交道。为了不在工作中拖后腿，自己挤时间把《SQL必知必会》这本书看完了。看完之后虽然对SQL有了基本的认识，但是应用起来还是不太熟练，有时候还需要上网查一查相关资料才用。现在把日常使用中会用到的点记录下来，方便以后应用。</p><span id="more"></span><h2 id="如何比较两个表的内容是否完全一致">1、如何比较两个表的内容是否完全一致</h2><h3 id="分组-inner-join">（1）、分组 inner join</h3><p>  这个问题我一直没有找到比较简洁有效的方式。看网上有一种做法，假设我们有两个表t1， t2。</p><p>  首先对t1按行分组，计算分组的条数num1。</p><p>  然后对t2按行分组，计算分组的条数num2。</p><p>  最后两个表t1、t2进行inner join，按照所有的列名字以及num进行关联。</p><p>  若num1=num2=inner join之后的条数，则说明两个表的内容完全一致。</p><p>  假设表结构如下所示，只有两列</p><table><thead><tr class="header"><th style="text-align: center;">id</th><th style="text-align: center;">name</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">xx1</td><td style="text-align: center;">Tom</td></tr><tr class="even"><td style="text-align: center;">xx2</td><td style="text-align: center;">Jone</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs sql">对t1进行分组<br><span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br><span class="hljs-keyword">from</span> t1 <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name;<br><br>对t2进行分组<br><span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br><span class="hljs-keyword">from</span> t2 <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name;<br><br>使用t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br>  (<span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br>  <span class="hljs-keyword">from</span> t1 <br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name) <span class="hljs-keyword">as</span> tmp1<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span><br>   (<span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br>    <span class="hljs-keyword">from</span> t2 <br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name) <span class="hljs-keyword">as</span> tmp2<br> <span class="hljs-keyword">on</span> tmp1.id<span class="hljs-operator">=</span>tmp2.id <span class="hljs-keyword">and</span> tmp1.name<span class="hljs-operator">=</span>tmp2.name;<br></code></pre></td></tr></table></figure><p>  若上面第一步num1值等于第二步的num2值，并且等于第三步输出的个数，说明两个表的内容是完全一样的。这个做法对于表的column比较少的情况比较方便，一旦column很大的情况下写起来就不太方便了。</p><h3 id="minus-做减法">（2）、minus 做减法</h3><p>  另一种做法是直接用两个表相互做减法，看返回的是否均为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1<br>minus <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2<br>minus<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1;<br></code></pre></td></tr></table></figure><p>如果返回的内容均为空的话，就说明两个表的内容完全一致，但是<strong>对于表中有重复的行的话这种方法就不适用了。</strong> 还有我在hue页面尝试这个方法的时候，提示我没有minus这个关键字。下次得去hive客户端试试了。</p><p><a href="https://zhuanlan.zhihu.com/p/113617244"></a></p><h2 id="分区表字段处理">2、分区表字段处理</h2><h3 id="增加新的字段">1、增加新的字段</h3><p>  之前遇到一个问题，就是一个非空分区表需要添加新的字段，然后把数据写入进去。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_nam <span class="hljs-keyword">add</span> columns(c1 <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>添加完字段之后，发现写入进去之后c1这个列全为null，当时以为是自己计算的错误。然后我在写入之前查了下，发现c1这个字段的数据是有的并且不为null，但是但是写入之后就为null了。后来查资料说到是添加新的字段的方式有问题，然后只能把那个表删掉，重新建表，写入数据。</p><p>对于非空分区表添加新的字段的正确方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">add</span> columns(c1 <span class="hljs-type">int</span>) cascade;<br></code></pre></td></tr></table></figure><p><a href="https://community.cloudera.com/t5/Community-Articles/Adding-new-columns-to-an-already-partitioned-Hive-table/ta-p/245636"></a></p><p><a href="https://blog.csdn.net/aijiudu/article/details/79066835"></a></p><h3 id="调整字段的位置">2、调整字段的位置</h3><p>  有时候我们的表建好，写入数据之后，又想添加新的字段，或者想把一些物理意义较近的字段放在一起，所以我们需要调整字段，所以如何调整字段的位置呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name c1 c1 <span class="hljs-type">float</span> after c2 cascade;<br></code></pre></td></tr></table></figure><p>  上面的sql就是把float类型的c1字段移动到c2后面，对于分区表注意使用cascade哦。</p><h2 id="将一个表的内容写入到另一个表中">3、将一个表的内容写入到另一个表中</h2><p>  如果是覆盖原始数据的话，直接使用insert overwrite</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> overwrite <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">partition</span>(dt<span class="hljs-operator">=</span>’t’)<br>       <span class="hljs-keyword">Select</span> col1, col2, col2,….<br>       <span class="hljs-keyword">From</span> table_name<br>       <span class="hljs-keyword">Where</span> dt<span class="hljs-operator">=</span>’t<span class="hljs-number">-1</span>’<br><br></code></pre></td></tr></table></figure><p>上面是将同一个表中一个分区的写入到另一个分区内。</p><p>  直接写入一个分区内，相当于追加到对应的分区内。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">partition</span>(dt<span class="hljs-operator">=</span>’t’)<br>       <span class="hljs-keyword">Select</span> col1, col2, col2,….<br>       <span class="hljs-keyword">From</span> table_name<br>       <span class="hljs-keyword">Where</span> dt<span class="hljs-operator">=</span>’t<span class="hljs-number">-1</span>’<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：分区字段要写完整</p><p>​ 选择数据时不能使用 select <em>， 因为select </em> 会选中所有字段，包括分区字段，但是我们写入的表中分区字段是作为文件夹名字的， 即实际表中没有分区字段，假如我们表中有7个字段（非分区字段），另外还有4个分区字段，我们在select * 的时候会选出11个字段，但是我们写入的表只有7个字段需要被写入，这样的话就会报错。</p><p>因此我们在选择数据时，要用select 选出那7个非分区字段。</p><h2 id="创建表的方式">4、创建表的方式</h2><h3 id="直接建表法">1、直接建表法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1(<br>    id      <span class="hljs-type">int</span>,<br>    name    string,<br>    hobby   <span class="hljs-keyword">array</span><span class="hljs-operator">&lt;</span>string<span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-keyword">add</span>     map<span class="hljs-operator">&lt;</span>String,string<span class="hljs-operator">&gt;</span><br>)<br><span class="hljs-type">row</span> format delimited<br>fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span><br>collection items terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;-&#x27;</span><br>map keys terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;:&#x27;</span><br>;<br></code></pre></td></tr></table></figure><p>然后load data进入到表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/user/hive/warehouse/...data&#x27;</span> overwrite <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> t1;<br></code></pre></td></tr></table></figure><h3 id="select-方法">2、select 方法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1 <span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span><br>    id,<br>    name<br><span class="hljs-keyword">from</span> t2;<br></code></pre></td></tr></table></figure><h3 id="like建表法">3、like建表法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1<br><span class="hljs-keyword">like</span> t2;<br></code></pre></td></tr></table></figure><h2 id="删除文件">5、删除文件</h2><h3 id="删除文件-1">1、删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -rm -r /user/hive/warehouse/database/table_name/dt=xxxx/city_code=xxxxx<br><br></code></pre></td></tr></table></figure><p>上述命令直接在terminal中执行即可，其实就是常用的linux命令前面加上hadoop fs，还有列出某个表的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -ls /user/hive/warehouse/database/table_name/dt=xxxx<br></code></pre></td></tr></table></figure><h3 id="删除分区">2、删除分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">alter table table_name drop if exists partition(dt=xxxx, city_code=xxxx);<br><br></code></pre></td></tr></table></figure><p>上述命令需要在hive客户端中执行。</p><h2 id="时间处理">6、时间处理</h2><h3 id="转换为时间戳">1、转换为时间戳</h3><p>标准格式是指'2021-06-30 10:10:00'这种格式，即'yyyy-MM-dd HH:mm:ss'，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unix_timestamp(<span class="hljs-string">&#x27;2021-06-30 10:10:10&#x27;</span>)<br></code></pre></td></tr></table></figure><p>若时间不是标准格式的，比如 '20210630'这种的情况，也可以使用unix_timestamp来转换，但是需要你传入格式，即告诉这个函数你的时间是什么格式的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unix_timestamp(<span class="hljs-string">&#x27;20210630&#x27;</span>, <span class="hljs-string">&#x27;yyyyMMdd&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="时间戳转换为日期">2、时间戳转换为日期</h3><p>时间戳转换为标准格式/指定格式，需要用到from_unixtime(date, format)，此时的时间是到秒级的，即你的时间戳长度为10位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">from_unixtime(<span class="hljs-string">&#x27;1625839005&#x27;</span>, <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)<span class="hljs-operator">/</span>from_unixtime(<span class="hljs-string">&#x27;1625839005&#x27;</span>, <span class="hljs-string">&#x27;yyyy-MM-dd&#x27;</span>)<br></code></pre></td></tr></table></figure><p>对于一些时间戳是到毫秒级其长度为13位，因此我们在转换前需要先取其前10位，即<strong>对字符串进行截取指定长度</strong>，这个在mysql和hivesql中是由一些差异的。<strong>在mysql中有left，right两个函数，但是在hive中可以使用substr来做</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">from_unixtime((<span class="hljs-built_in">cast</span>(substr(<span class="hljs-string">&#x27;1625839005000&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">bigint</span>)), <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="分位数">7、分位数</h2><p>在hivesql中，取分位数还是比较简单，有两个函数可供使用，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">percentile(col, p)<br></code></pre></td></tr></table></figure><p>col为我们要处理的列，但是要求col的值必须都为int，p为0-1的小数，表示分位数，0.3表示3分位数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">percentile_approx(col, <span class="hljs-keyword">array</span>(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>), <span class="hljs-number">9999</span>)<br></code></pre></td></tr></table></figure><p>col也是我们要处理的列，此时该列的值可以为浮点型也可以为整型，后面可以穿入一个array，一次取多个分位数</p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下压缩隐藏文件</title>
    <link href="/2020/05/03/Linux%E4%B8%8B%E5%8E%8B%E7%BC%A9%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"/>
    <url>/2020/05/03/Linux%E4%B8%8B%E5%8E%8B%E7%BC%A9%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下压缩文件">Linux下压缩文件</h1><p>  之前在压缩文件的时候一直使用tar这个命令，因为一般压缩的时候都是对我们能“看见”的文件进行压缩，没有考虑过那些看不见的文件，即“隐藏”文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz abc/*   // 压缩<br>tar zxvf abc.tar.gz         // 解压<br></code></pre></td></tr></table></figure><p>  最近在服务器上压缩文件时，需要用到里面的隐藏文件，想当然的进行了上面的压缩方式，解压之后发现找不到隐藏文件。一阵查找资料后才发想，上面的做法只是<strong>压缩指定文件夹下面的非隐藏文件与文件夹</strong>。</p><p>  因此查找资料后发现，对于隐藏和非隐藏文件的压缩方式还有些不同。如果想要对隐藏的文件做处理，需要<strong>显示的指定</strong>出来才可以。我们都知道隐藏的文件或文件夹都是以“.”开头的。所以就需要用到正则表达式来处理了：</p><span id="more"></span><h2 id="压缩非隐藏文件">压缩非隐藏文件</h2><p>  注意只压缩非隐藏文件，不包括文件夹的话是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zcvf abc.tar.gz *.*   // 压缩当前文件夹下非隐藏文件不包括文件夹<br></code></pre></td></tr></table></figure><p>  压缩所有的非隐藏文件，包括文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz *       <br></code></pre></td></tr></table></figure><h2 id="压缩隐藏文件">压缩隐藏文件</h2><p>  如果要压缩隐藏文件的话，要显示的指示出来</p><p>  压缩当前文件下的隐藏文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz .[!.]*   // 只压缩当前文件夹下隐藏文件排除两个隐藏文件夹&quot;.&quot;和“..”   <br></code></pre></td></tr></table></figure><p>上面的.[!.]其实就是正则表达式，表示第一个字符是“.”，第二个字符不是"."，第三个以及后面可以是任意字符。</p><p>  压缩当前文件夹下的所有文件夹以及隐藏的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz .[!.]* *  // 压缩当前文件夹下所有文件和目录包括隐藏文件  <br></code></pre></td></tr></table></figure><p>这条命令比上一条命令多了一个*，表示当前文件夹下的所有文件以及文件夹。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
