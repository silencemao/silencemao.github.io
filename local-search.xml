<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>XGBoost介绍</title>
    <link href="/2022/04/05/XGBoost%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/04/05/XGBoost%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一简介">一、简介</h1><p>  XGBoost(eXtreme Gradient Boosting)又叫极度梯度提升树，是boosting算法的一种实现方式。针对分类或回归问题，效果非常好。在各种数据竞赛中大放异彩，而且在工业界也是应用广泛，主要是因为其效果优异，使用简单，速度快等优点。本文主要从以下几个方面介绍该算法模型：</p><p><img src="/images/xgb.png" /></p><h1 id="二基本原理">二、基本原理</h1><p>  xgb是boosting算法的一种实现方式，主要是降低偏差，也就是降低模型的误差。因此它是采用多个基学习器，每个基学习器都比较简单，避免过拟合，下一个学习器是学习前面基学习器的结果<span class="math inline">\(y^{t}_{i}\)</span>和实际值<span class="math inline">\(y_{i}\)</span>的差值，通过多个学习器的学习，不断降低模型值和实际值的差。 <span class="math display">\[y_{i}^{0} = 0\]</span> <span class="math display">\[y_{i}^{1} = f_{1}(x_{i}) = y_{i}^{0}+f_{1}(x_{i})\]</span> <span class="math display">\[$y_{i}^{2}=f_{1}(x_{i})+f_{2}(x_{i})=y_{i}^{1}+f_{2}(x_{i})\]</span> <span class="math display">\[y_{i}^{t}=\sum_{k=1}^{t}f_{k}(x_{i})=y_{i}^{t-1}+f_{t}(x_{i})\]</span> 基本思路就是不断生成新的树，每棵树都是基于上一颗树和目标值的差值来进行学习，从而降低模型的偏差。最终模型结果的输出如下：<span class="math inline">\(y_{i}=\sum_{k=1}^{t}f_{k}(x_{i})\)</span>，即所有树的结果累加起来才是模型对一个样本的预测值。那在每一步如何选择/生成一个较优的树呢？那就是由我们的<strong>目标函数</strong>来决定。</p><h1 id="三目标函数">三、目标函数</h1><p>  目标函数由两部分组成，一是模型误差，即样本真实值和预测值之间的差值，二是模型的结构误差，即正则项，用于限制模型的复杂度。 <span class="math display">\[Obj(\theta)=L(\theta)+\Omega(\theta)=L(y_{i},y_{i}^{t})+\sum_{k=1}^{t}\Omega(f_{k}(x_{i}))\]</span> 因为<span class="math inline">\(y_{i}^{t}=y_{i}^{t-1}+f_{t}(x_{i})\)</span>，所以将其带入上面的公式中转换为： <span class="math inline">\(Obj^{t}=\sum_{n=1}^{n}L(y_{i},y_{i}^{t-1}+f_{t}(x_{i}))+\Omega(f_{t})+\sum_{t=1}^{T-1}\Omega(f_{t})\)</span>，第t颗树的误差由三部分组成，n个样本在第t颗树的误差求和，以及第t颗树的结构误差和前t-1颗树的结构误差。其中前t-1颗树的结构误差是常数，因为我们已经知道前t-1颗树的结构了。   <strong>假设</strong>我们的损失函数是平方损失函数(mse)，则上述目标函数转换为： <span class="math display">\[Obj^{t}=\sum_{i=1}^{n}L(y_{i},y_{i}^{t-1}+f_{t}(x_{i}))+\Omega(f_{t})+\sum_{t=1}^{T-1}\Omega(f_{t}) \\ =\sum_{i=1}^{n}(y_{i}-(y_{i}^{t-1}+f_{t}(x_{i})))^2+\Omega(f_{t})+constant\]</span> 上述公式即为损失函数为mse时xgb第t步的目标函数。唯一的变量即为<span class="math inline">\(f_{t}\)</span>，此处的损失函数仍然是一个相对复杂的表达式，所以为了简化它，采用二阶泰勒展开来近似表达，即<span class="math display">\[f(x+\Delta x)=f(x)+f^{&#39;}(x)\Delta x+1/2f^{&#39;&#39;}(x)\Delta x^2\]</span>，所以另<span class="math inline">\(g_{i}=\partial _{y_{i}^{t-1}}l(y_{i},y_{i}^{t-1})\)</span>，<span class="math inline">\(h_{i}=\partial _{y_{i}^{t-1}} ^ 2 l(y_{i},y_{i}^{t-1})\)</span>，即分别是<span class="math inline">\(l(y_{i},y_{i}^{t-1})\)</span>的一阶导和二阶导。则上述损失函数转换为二阶导之后，<span class="math display">\[Obj^{t}=\sum_{i=1}^{n}[l(y_{i},y_{i}^{t-1})+g_{i} f_{t}(x_{})+1/2h_{i} f_{t}^2(x)]+\Omega(f_{t})+constant\]</span>，   所以当损失函数是mse时，<span class="math inline">\(g_{i}=2(y_{i}^{t-1}-y_{i})\)</span>，<span class="math inline">\(h_{i}=2\)</span>。   经过转换之后，其中第一项是所有样本与第t-1颗树的误差之和，因为第t-1颗树是已知的，所以可以将其视为常数项，我们暂时在目标函数中将其舍去，我们的目标函数变为关于<span class="math inline">\(f_{t}(x)\)</span>的函数了。而<span class="math inline">\(f_{t}(x)\)</span>则是关于叶子节点输出<span class="math inline">\(w\)</span>的函数，所以我们的目标函数全部转换为关于<span class="math inline">\(w\)</span>的函数，<span class="math display">\[Obj^{t}=\sum_{i=1}^{n}[g_{i} f_{t}(x_{})+1/2h_{i} f_{t}^2(x)]+\Omega(f_{t})+constant \\ =\sum_{i=1}^{n}[g_{i}w_{q}(x_{i})+1/2h_{i}w_{q}^2(x_{i})]+\gamma T+1/2\lambda\sum_{j=1}^{T}w_{j}^{2} \\ =\sum_{j=1}^{T}[\sum_{i \in I_{j}}(g_{i})*w_{j}+1/2*\sum_{i \in I_{j}}(h_{i}+\lambda)w_{j}^2]+\gamma T\]</span>。我们令<span class="math inline">\(G_{j}=\sum_{i \in I_{j}}(g_{i})\)</span>，令<span class="math inline">\(H_{j}=\sum i \in I_{j}(h_{i})\)</span>，则我们的目标函数转换为<span class="math display">\[Obj^{t}=\sum_{j=1}^{T}G_{j}*w_{j}+1/2(H_{j}+\lambda)*w_{j}^{2}+\lambda T\]</span>。在上述表达式中，<span class="math inline">\(j表示第j个节点\)</span>，<span class="math inline">\(i表示第i个样本\)</span>。所以整个目标函数转换成了关于<span class="math inline">\(w\)</span>即叶节点分数的一元二次函数，想要优化目标函数，就是求解最优的w，因此我们对目标求导，得到<span class="math display">\[w^{*}=-G_{i}/(H_{i}+\lambda)\]</span>，将<span class="math inline">\(w^{*}\)</span>代入目标函数中，则目标函数变为<span class="math display">\[Obj^{t}=-1/2\sum_{j=1}^{T}G_{j}^{2}/(H_{j}+\lambda)+\lambda T\]</span>。如此简单，所以在求解二叉树的目标函数时，只要知道损失函数的一阶导、二阶导，以及样本落在哪个叶子节点上，我们只要求出在每个叶子节点上，该样本的一阶导和二阶导就能求出目标函数。也就能决定是否分裂该节点，依据哪个节点的特征值来进行分裂。</p><h2 id="三节点分裂">三、节点分裂</h2><p>   xgb节点是否分裂取决于信息增益的变化，若分裂当前节点，信息增益&gt;0，则进行分裂，若不大于0则不分裂，如何判断分列前后信息增益的变化呢。那就可以使用我们的目标函数来表示了。 <span class="math display">\[Gain=G_{L}^{2}/(H_{L}+\lambda)+G_{R}^{2}/(H_{R}+\lambda)-(G_{L}+G_{R})^2/(H_{L}+H_{R}+\lambda)+\gamma\]</span>   节点分裂有两种方式：1、贪心算法，2、近似算法。</p><h3 id="贪心算法">3.1 贪心算法</h3><p>  贪心算法分裂的方式就是一种暴力搜索的方式，遍历每一个特征，遍历该特征的每一个取值，计算分裂前后的增益，选择增益最大的特征取值作为分裂点。 <img src="/images/xgb1.png" alt="贪心算法" /> 分裂流程如上图所示。</p><h3 id="近似算法">3.2 近似算法</h3><p>   近似算法，其实就是分桶，目的是为了提升计算速度，降低遍历的次数，所以对特征进行分桶。就是将每一个特征的取值按照分位数划分到不同的桶中，利用桶的边界值作为分裂节点的候选集，每次遍历时不再是遍历所有特征取值，而是仅遍历该特征的几个桶（每个桶可以理解为该特征取值的分位数）就可以，这样可以降低遍历特征取值的次数。</p><figure><img src="/images/xgb2.png" alt="近似算法" /><figcaption aria-hidden="true">近似算法</figcaption></figure><p>  分桶算法分为global模式和local模式，global模式就是在第一次划分桶之后，不再更新桶，一直使用划分完成的桶进行后续的分裂。这样做就是计算复杂度降低，但是经过多次划分之后，可能会存在一些桶是空的，即该桶中已经没有了数据。   local模式就是在每次分列前都重新划分桶，优点是每次分桶都能保证各桶中的样本数量都是均匀的，不足的地方就是计算量大。</p><h2 id="四其它特点">四、其它特点</h2><h3 id="缺失值处理">4.1 缺失值处理</h3><p>   对于存在某一维特征缺失的样本，xgb会尝试将其放到左子树计算一次增益，再放到右子树计算一次增益，对比放在左右子树增益的大小决定放在哪个子树。</p><h3 id="防止过拟合">4.2 防止过拟合</h3><p>   xgb提出了两种防止过拟合的方法：第一种称为Shrinkage，即学习率，在每次迭代一棵树的时候对每个叶子结点的权重乘上一个缩减系数，使每棵树的影响不会过大，并且给后面的树留下更大的空间优化。另一个方法称为Column Subsampling，类似于随机森林选区部分特征值进行建树，其中又分为两个方式:方式一按层随机采样，在对同一层结点分裂前，随机选取部分特征值进行遍历，计算信息增益；方式二在建一棵树前随机采样部分特征值，然后这棵树的所有结点分裂都遍历这些特征值，计算信息增益。</p><h2 id="五总结">五、总结</h2><p>  以上是对xgb的一些理解，大多是观看了很多大神的博客，通过不断的看别人总结的部分以及公式的推导，才让我逐渐理解xgb的各种特征。本文还是有很多不足的地方，后续逐渐补充，完善。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2022/01/03/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2022/01/03/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h3 id="决策树三要素"><a href="#决策树三要素" class="headerlink" title="决策树三要素"></a>决策树三要素</h3><ol><li><p>特征选择</p></li><li><p>决策树生成</p></li><li><p>决策树剪枝</p><ol><li><p>预剪枝</p><p>限制树的深度，叶子节点个数，叶子节点样本数，信息增益等</p></li><li><p>后剪枝</p><p>正则化</p></li></ol></li></ol><h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h3><p>&emsp;&emsp;ID3是根据信息增益来选择特征，将数据划分成多份，构成决策树。</p><h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>&emsp;&emsp;信息增益是什么呢？划分数据前后 数据中<strong>“信息量”</strong>的 变化，通常选择信息增益最大的特征作为当前划分的依据。</p><h4 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h4><p>&emsp;&emsp;如何衡量<strong>“信息量”</strong>呢？这里引入熵的概念，熵表示信息不确定性的程度，熵越大，不确定性越强，熵越小，不确定性越小(越确定)。熵的公式如下：</p><script type="math/tex; mode=display">H(X)=-sum_{i=1}^{i=n}p_{i}*log(p_{i})</script><p>&emsp;&emsp;n样本是分类的个数，$p_{i}$表示样本分类为类别i的概率。熵的大小是和每个类别的概率有关的。</p><p><img src="/images/entropy.png" alt=""></p><p>&emsp;&emsp;熵和概率的关系如上图所示：随着概率从小变大，熵的值先增大道最大值然后降到最小值，当概率值$p=0.5$时，熵值最大，说明不确定性越大，当概率值$p=0.9$时，熵值最小，不确定性越小。</p><h4 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h4><p>&emsp;&emsp;对于条件熵，则是当X的取值确定之后，在这个条件下的熵值。即当我们确定了样本某特征X的取值之后，即在这个条件下的熵值，</p><script type="math/tex; mode=display">H(Y|X)=sum_{i=1}^{i=n}p_{i}*H(Y|X=x_{i})</script><p>&emsp;&emsp;举个例子我们有一波样本D，共有k个类别$C_{k}$，它的熵为H(D)，某一特征A有n个取值，依据特征A可以将数据集划分为n个子集，分别为$D_{1}$，$D_{2}$…$D_{n}$，首先计算每个子集的信息熵H(D|A)，然后计算每个子集的样本占总样本的比例$p_{i}$，然后将每个子集的信息熵*比例 加起来，就是特征A的条件熵。</p><p>&emsp;&emsp;所以回到ID3算法上，特征A对数据集D的信息增益就是<script type="math/tex">g(D,A)=H(D)-H(D|A)</script>。</p><p>&emsp;&emsp;在生成树的过程中，每次分裂时选择特征就是依据信息增益来选择最佳分裂点。选好最佳分裂点之后，依据特征取值将样本分成n(特征A取值的个数)叉树，然后在每个子树下面继续进行分裂，直到树生成完成。</p><h4 id="ID3算法的缺点："><a href="#ID3算法的缺点：" class="headerlink" title="ID3算法的缺点："></a>ID3算法的缺点：</h4><ol><li>ID3没有考虑连续值，对于特征取值为连续值的情况无法适用。</li><li>ID3选用信息增益作为分裂的依据，会更倾向于特征属性值多的作为分裂节点，举个例子：$-1/3<em>log(1/3)</em>3$ &gt; $-1/2<em>log(1/2)</em>2$。</li><li>ID3对于缺失值也无法出来，而且更容易过拟合。</li></ol><h4 id="为什么ID3倾向于特征属性值偏多的特征？"><a href="#为什么ID3倾向于特征属性值偏多的特征？" class="headerlink" title="为什么ID3倾向于特征属性值偏多的特征？"></a>为什么ID3倾向于特征属性值偏多的特征？</h4><p>&emsp;&emsp;信息增益是整个数据集的经验熵与特征a对整个数据集的经验条件熵的差值，信息增益越大即经验条件熵越小<br>通俗的来讲,信息增益反映的给定一个条件以后不确定性减少的程度(特征A使得数据集的分类不确定性减少的程度) , 肯定是是分得越细的数据集确定性更高,也就是条件熵越小,信息增益越大。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟退火算法</title>
    <link href="/2021/10/30/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2021/10/30/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="模拟退火算法">模拟退火算法</h2><p>  模拟退火算法是上世纪80年代产生的优化算法，应用于在较大空间中寻找问题的最优解，也是解决TSP问题的一大利器。模拟退火是物质从无序（高温）逐渐趋向（降温）于有序（低温/恒温）的过程。因此在模拟退火算法优化的过程中，从始至终是有一个温度贯穿其中的。那温度在优化过程中起到的作用是什么呢？</p><span id="more"></span><h3 id="算法简介">算法简介</h3><p>  针对一个优化问题，存在非常多的解，可以采用模拟退火（sa）算法逐渐的逼近最优解。它的求解过程是：从一个初始解出发，然后进行局部搜索，获得一个新解，是否接受新解由模拟退火来决定，所以sa在其中起到的作用就是是否接受当前这个新的解。</p><p>  sa中包含几个参数:T温度，$$ 降温系数，n迭代次数。n是指在每个温度T下的迭代次数。具体执行流程如下图所示：</p><figure><img src="/images/sa.png" alt="sa" /><figcaption aria-hidden="true">sa</figcaption></figure><p>模拟退火中的T和n控制整个流程的进行，在每个温度T下都要执行n步（即n次迭代），n步执行完成之后，更新T。每次得到新解之后，都要对新解进行判断，是否接受。假设我们的优化目标（衡量新解的方法）为<span class="math inline">\(f(x)\)</span>，我们求解的过程中是优化目标的值越小越好，所以如何来衡量新解与旧解的优劣呢。<strong>若新解优于上一步的解，直接接受，若不优于上一步的解，则有概率的接受</strong>。依据下面的公式：</p><p><span class="math display">\[rand &lt; exp(-(f(x&#39;)-f(x)) / T)\]</span></p><p>来确定新解是否接受。指数函数的图像如下图所示：</p><figure><img src="/images/exp.gif" alt="exp" /><figcaption aria-hidden="true">exp</figcaption></figure><p>当新解比旧解要差时，<span class="math inline">\(-(f(x&#39;)-f(x)) &lt; 0\)</span>，即指数幂值在y轴的左侧，当T值较大时，指数幂值在靠近y轴的左侧部分，即概率值较大，接受较差解的概率要高一些，当随着温度T的下降，指数幂值值也降低，接受差解的概率较小。即模拟退火算法也是在前期可以较高概率的接受差解，从而快速跳出局部最优，随着搜索的进行，温度T逐渐下降，便不容易跳出当前范围。这也有点像深度学习调参的过程，初期学习率lr较大，随着求解过程的进行，学习率lr降低是一样的道理。<strong>若想在后期也以一个较大的概率接受差解，随着温度的降低或迭代次数的进行 可以在分母上乘一个值，提高分母的值，增大概率</strong>。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;GoProject/algorithm/heuristic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFuncRes</span><span class="hljs-params">(x, y <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span>&#123; <span class="hljs-comment">// 目标函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">6.0</span> * math.Pow(x, <span class="hljs-number">7</span>) + <span class="hljs-number">8.0</span> * math.Pow(x, <span class="hljs-number">6</span>)  + <span class="hljs-number">7.0</span> * math.Pow(x, <span class="hljs-number">3</span>) + <span class="hljs-number">5</span> * math.Pow(x, <span class="hljs-number">2</span>) - x*y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimulateAnneal</span><span class="hljs-params">()</span></span> &#123;<br>result := math.MaxFloat64<br>t := <span class="hljs-number">100.0</span><br>minT := <span class="hljs-number">1e-8</span><br>iterNum := <span class="hljs-number">10000</span><br>delta := <span class="hljs-number">0.98</span><br>rand.Seed(<span class="hljs-number">0</span>)<br>x := rand.Float64() * <span class="hljs-number">100</span><br>bestX := x<br>fmt.Println(bestX)<br><br>cnt := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> t &gt; minT &amp;&amp; iterNum &gt;= <span class="hljs-number">0</span> &#123;<br>xNew := x + rand.Float64() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> xNew &gt;= <span class="hljs-number">0</span> &amp;&amp; xNew &lt;= <span class="hljs-number">100</span> &#123;<br>cnt++<br>funcNew := getFuncRes(xNew, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> funcNew &lt; result &#123;<br>x = xNew<br>bestX = x<br>result = funcNew<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p := math.Exp(<span class="hljs-number">-1</span> * (funcNew - result) / t)<br><span class="hljs-keyword">if</span> rand.Float64() &lt; p &#123;<br>x = xNew<br>&#125;<br><span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">//fmt.Println(&quot;prob &quot;, p)</span><br>&#125;<br><br>&#125;<br>&#125;<br>iterNum--<br>t = t * delta<br>&#125;<br>fmt.Println(bestX, result, cnt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LateAcc</span><span class="hljs-params">()</span></span> &#123;<br><br>rand.Seed(<span class="hljs-number">0</span>)<br><br>bestX := rand.Float64() * <span class="hljs-number">100</span><br>bestRes := <span class="hljs-number">0.0</span><br><br>pLa := <span class="hljs-built_in">new</span>(heuristic.LateAcceptance)<br>pLa.Init(<span class="hljs-number">200</span>)<br><br>pIterNum := <span class="hljs-number">10000</span><br>cnt := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> pIterNum &gt; <span class="hljs-number">0</span> &#123;<br>x := bestX + rand.Float64() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">100</span> &#123;<br>cnt++<br>pRes := getFuncRes(x, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> pLa.Accept(pRes) &#123;<br>bestX = x<br>bestRes = pRes<br>&#125;<br>&#125;<br>pIterNum--<br>&#125;<br>fmt.Println(bestX, bestRes, cnt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>SimulateAnneal()<br>LateAcc()<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟退火</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark-使用总结</title>
    <link href="/2021/07/20/Spark-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/20/Spark-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作心得总结</title>
    <link href="/2021/07/10/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/10/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="工作经验总结">工作经验总结</h2><h3 id="为什么要写这个总结">为什么要写这个总结</h3><p>  自己工作以来，前期的成长还是比较快的，可以快速的学习技术，业务知识，与人沟通的能力，但是也有几点没有学好，比如：总结的能力，展示汇报的能力，以及表达自己观点的能力...这几点自身感觉是没有明显的提升。可能与我自身的性格、想法有关，仿佛自己一直在觉着只要写好代码，做好工作就行了，最开始还觉着很潇洒，慢慢觉着这样并不好，<strong>一直停留在固有的思维层面，这是比较可怕的</strong>。</p><span id="more"></span><p>  曾经有人对我说，要想成长，要学会适当的跳出当前的层级去思考问题，去考虑更高一点层级的问题，格局要大。说实话我第一次听到这样的话时，感觉有点虚、假，甚至有些pua的意味。可是转念一想，并不是完全没有道理，假如我们一直按照自己的固有思维去考虑问题，我们一直停留在一个水平面。当别人给我们指点时，我们会有恍然大悟的感觉，如果此时我们能反思为什么别人会这样思考，为什么他能想到自己没有想到的一点，如果能得到别人这样思考的原因，我们也就在慢慢向其靠近。</p><p>  工作了两年时间之后，发现自己的成长的确越来越慢，似乎有一点停滞。有时候仿佛被忙碌蒙蔽了双眼，曾经有一段时间特别忙，特别累，但是却在做着重复性的工作，好像一直都没有成长。当忙碌的节奏停了下来，回头一看才发现自己这一段时间只是忙碌，却收获甚少。而身处工作中，忙碌是必不可少的，可是我们要如何在忙碌中成长呢，那就是要不断的总结，也就是我想写这篇博客的原因。不断的把工作中的想法、心得记录下来，督促自己。</p><h3 id="总结ing....">总结ing....</h3><p>1、处理数据时要考虑数据的完整性、正确性，处理完成之后要记得校验。</p><p>2、若要通过做图反应自己产出的数据，要考虑受众范围，比如坐标轴的解释。若数据范围跨度比较大，不能很好的展示细节，是否可以滤除一些异常值，只展示部分范围，把细节展示出来。</p><p>3、与人沟通时，先假设对方的出发点是对我们好，这样二者的立场会先一致，不容易引起矛盾，若不合适，再表达自己的观点也不迟。</p><p>....</p><p>Wo wo wo</p><h3 id="共勉">共勉</h3>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资源均分</title>
    <link href="/2021/06/04/%E8%B5%84%E6%BA%90%E5%9D%87%E5%88%86/"/>
    <url>/2021/06/04/%E8%B5%84%E6%BA%90%E5%9D%87%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="资源均分">资源均分</h2><h2 id="背景">背景</h2><p>  这道题目说实话我目前还不知道最优或者标准的做法是什么，它不像是一些标准的dp、树啊之类的问题。</p><h2 id="题目">题目</h2><p>  假设在中东各个国家都有一定的石油库存，每个国家的库存可能不一样，现在你作为掌管石油的老大，你手中有M吨石油，如何分配石油给这些国家，<strong>让整体的石油分布看上去比较均衡</strong>，你可以分配手中的M吨石油，但是不能在各个国家之间调拨石油。你分配的越好，越不会引起战争。</p><span id="more"></span><p>  这里有两点需要注意，</p><p>1、整体的分布比较均衡，并没有说具体的衡量标准是什么，如何定义均衡需要自己思考。</p><p>2、各个国家之间的石油不能相互调拨，你只能分配手中的M吨石油。</p><p>  这里的看上去均衡，并不是一定要求大家的石油都一样，而是让国家之间的石油分布差异不是很大，若能完全均衡当然是最好。</p><p>我的第一个思路是找到最大的那个国家的石油n，然后计算其它国家与的石油与n的差值，然后从m中分配出一部分石油来弥补这个差值。若最后m依然&gt;0，然后将这部分石油再均分即可。可是发现这个做法有很多边界case是不满足的，当最多的石油与最少的石油差值大于m时，其它国家完全没有分配，这未必是一种均衡方式。</p><p>第二个思路是采用运筹的方式来解决，因为可以动态的去搜索石油的分布，根据我们定义的score来衡量是否均衡，是否接受当前的搜索结果。同时也可以根据我们最大与最小的差值来分配两者之间的石油（此处分配是保证每个国家的石油&gt;=最初的状态，所以不属于国家之间的调拨），让最大与最小的差值不断缩小，趋向于均衡。</p><h3 id="score如何定义">score如何定义</h3><p>  此处我是定义了两部分score，第一部分是任意两个国家之间的石油差值，第二部分是每个国家的石油与平均值的差值。两个score相加作为最终的score，整体的score越小表示分布的相对均衡。</p><h3 id="算法如何设计">算法如何设计</h3><p>  我考虑采用模拟退火来作为是否接受新解，若新解满足接受条件，则接受新解，若优于当前最优解，则更新最优解。温度降到最小值之后则停止搜索，返回结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></div></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> r = rand.New(rand.NewSource(<span class="hljs-number">0</span>)) <span class="hljs-comment">// 用于搜索</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> -num<br>&#125;<br><span class="hljs-keyword">return</span> num<br>&#125;<br><br><span class="hljs-comment">// 计算score</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateScore</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>sum += nums[i]<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>res += abs(nums[j] - nums[i])<br>&#125;<br>&#125;<br>sum /= <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>res += abs(sum - nums[i])<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, m <span class="hljs-keyword">int</span>)</span></span> &#123;<br>T, minT, ratio := <span class="hljs-number">100.0</span>, <span class="hljs-number">0.0001</span>, <span class="hljs-number">0.99</span> <span class="hljs-comment">// 初始化最高温度，最低温度，降温速率</span><br><br>tmp := <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, nums...)<br>fix := initial(<span class="hljs-built_in">len</span>(nums), m) <span class="hljs-comment">// 将m分配完成</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>tmp[i] += fix[i]<br>&#125;<br>s1 := calculateScore(tmp)          <span class="hljs-comment">// 计算score</span><br>bestNum := <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, tmp...) <span class="hljs-comment">// 存储最优解</span><br>fmt.Println(bestNum)<br><br><span class="hljs-keyword">for</span> T &gt; minT &#123;<br>iter := <span class="hljs-number">500</span><br><span class="hljs-keyword">for</span> iter &gt; <span class="hljs-number">0</span> &#123;<br>pre := <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, tmp...)<br><br>localSearch(nums, pre) <span class="hljs-comment">// 搜索</span><br>s2 := calculateScore(pre)<br><span class="hljs-keyword">if</span> s2 &lt; s1 &#123; <span class="hljs-comment">// 若新解优于最优解，直接接受</span><br>bestNum = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, pre...)<br>tmp, s1 = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, pre...), s2<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> math.Exp(-<span class="hljs-keyword">float64</span>(s2-s1)/T) &lt; r.Float64() &#123; <span class="hljs-comment">// 有概率接受</span><br>tmp, s1 = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, pre...), s2<br>&#125;<br>iter--<br>&#125;<br>T *= ratio<br>&#125;<br><span class="hljs-comment">//nums = bestNum  不会生效</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>nums[i] = bestNum[i]<br>&#125;<br>fmt.Println(bestNum)<br>&#125;<br><br><span class="hljs-comment">// 初始化 参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initial</span><span class="hljs-params">(cnt, m <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cnt<span class="hljs-number">-1</span>; i++ &#123;<br>num := r.Intn(m)<br>m -= num<br>res = <span class="hljs-built_in">append</span>(res, num)<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, m)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMaxMin</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>min, max := <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-number">32</span><br>ind1, ind2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> ind, num := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> num &gt; max &#123;<br>max, ind2 = num, ind<br>&#125;<br><span class="hljs-keyword">if</span> num &lt; min &#123;<br>min, ind1 = num, ind<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ind1, ind2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">localSearch</span><span class="hljs-params">(nums, tmp []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>minInd, maxInd := findMaxMin(tmp)<br><span class="hljs-keyword">if</span> nums[minInd] &gt; tmp[minInd] || nums[maxInd] &gt; tmp[maxInd] &#123;<br>tmp = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;&#125;, nums...)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> tmp[maxInd] &gt; nums[maxInd] &#123; <span class="hljs-comment">// 防止r.Intn() 报错</span><br>m := r.Intn(tmp[maxInd] - nums[maxInd])<br>tmp[minInd] += m<br>tmp[maxInd] -= m<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>sum += nums[i]<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">50</span>&#125;<br>m := <span class="hljs-number">200</span><br>sum := m + calculateSum(nums)<br>fmt.Println(nums, sum)<br><br>dispatch(nums, m)<br>fmt.Println(nums, calculateSum(nums))<br>&#125;<br><br>-------------------<br>[<span class="hljs-number">1</span> <span class="hljs-number">200</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">50</span>] <span class="hljs-number">458</span>  初始值<br>[<span class="hljs-number">75</span> <span class="hljs-number">272</span> <span class="hljs-number">16</span> <span class="hljs-number">28</span> <span class="hljs-number">67</span>]<br>[<span class="hljs-number">75</span> <span class="hljs-number">201</span> <span class="hljs-number">55</span> <span class="hljs-number">60</span> <span class="hljs-number">67</span>]<br>[<span class="hljs-number">75</span> <span class="hljs-number">201</span> <span class="hljs-number">55</span> <span class="hljs-number">60</span> <span class="hljs-number">67</span>] <span class="hljs-number">458</span> 最终分配结果<br><br></code></pre></td></tr></table></figure><h3 id="todo">todo</h3><p>1、score的定义未必合理，可以考虑再使用更优的score，比如每个国家的涨幅。。。</p><p>2、搜索方式也可以更丰富些。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源均分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prim算法</title>
    <link href="/2021/04/11/Prim%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/11/Prim%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="prim算法">Prim算法</h2><p>  假定我们要给各个村子修路，将村子之间互相连通起来，但是呢又不想直在任意两两村子之间直接修，那样会浪费成本。因此我们可以考虑在部分村子之间修，只要保证这些路可以将所有的村子连通起来就好（即村A和村B之间没有直接连通，但是可以通过村C来中转，从A-C-B）。也就是说<strong>我们有N个村子，我们可以修N-1条路，来保证村之间可以有路连通</strong>。也称为最小生成树（最小支撑树），即保持"连通性"的前提下的最小子图，子图各个边的权重之和最小。</p><span id="more"></span><h2 id="解决方案">解决方案</h2><h3 id="贪心法">贪心法</h3><p>  我们设定无向图G=(P, E)为连通图，P为G中的所有顶点，E为顶点之间的边。我们要从中筛选出部分边构成最小生成树，使的边权重之和最小。</p><p>我们定义V为已经修好路的顶点，U为还未进行修路的顶点，V中的顶点构成了最小生成树后的子树，U中的点会逐个进入V中，最终生成一个最小生成树。</p><p>1、首先我们将第一个顶点放入V中，并将其从U中删除。</p><p>2、从U中选择一个距离V最近的顶点<span class="math inline">\(u_k\)</span>，即从U中选择一个顶点，它距离V中所有点的最短距离，是U中的顶点的最小的。</p><p>3、将<span class="math inline">\(u_k\)</span>从U中删除，加入V中。</p><p>4、以此类推，直到U中为空，即得到了最小生成树的权重。</p><h2 id="代码逻辑">代码逻辑</h2><p>  第一种写法，我们首先将第一个顶点加入V中，然后开始尝试m-1次，将剩下的顶点依次纳入V中。重点在于如何求U中距离V最近的顶点，我们这里直接两层循环，遍历U中顶点，计算其与V中所有顶点的最短距离，保存距离最短的U中的顶点的索引。遍历结束，索引对应的U中顶点加入到V中即可。时间复杂度为<span class="math inline">\(O(n^3)\)</span></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prim</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>  m := <span class="hljs-built_in">len</span>(matrix)<br>  V := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>  <span class="hljs-keyword">var</span> U []<span class="hljs-keyword">int</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>    U = <span class="hljs-built_in">append</span>(U, i)<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; m<span class="hljs-number">-1</span>; k++ &#123;<br>    min := <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>    ind1, ind2 := <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> V &#123;<br>      <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> U &#123;<br>        <span class="hljs-keyword">if</span> matrix[V[i]][U[j]] &lt; min &#123;<br>          min = matrix[V[i]][U[j]]<br>          ind1, ind2 = i, j<br>        &#125;<br>      &#125;<br>    &#125;<br>    fmt.Println(V[ind1], U[ind2], min)<br>    V = <span class="hljs-built_in">append</span>(V, U[ind2])<br>    U = <span class="hljs-built_in">append</span>(U[:ind2], U[ind2+<span class="hljs-number">1</span>:]...)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  matrix := [][]<span class="hljs-keyword">int</span>&#123;<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">128</span>&#125;,<br>    &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">3</span>, <span class="hljs-number">128</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;,<br>  &#125;<br>  prim(matrix)<br>  fmt.Println()<br>  prim1(matrix)<br>&#125;<br></code></pre></td></tr></table></figure><p>  上面那种写法的时间复杂度比较高，我们可以考虑进行下优化。在找距离V最近的顶点时，是存在优化空间的。不需要每次都遍历V和U，我们可以用一个数组记录下U中顶点到V的最短距离。</p><p>1、dis数组的长度为顶点的个数，当V中只有第一个顶点<span class="math inline">\(v_0\)</span>，dis中记录了该顶点与U中所有顶点的最近距离（无向图，a-&gt;b = b-&gt;a）。</p><p>2、当V中新增一个顶点<span class="math inline">\(v_1\)</span>时，我们可以对dis进行一次更新。若U中存在顶点<span class="math inline">\(u_k\)</span>其距离<span class="math inline">\(v_1\)</span>的值小于其距离<span class="math inline">\(v_0\)</span>的值，我们就可以更新dis中的信息。</p><p>3、直接根据dis中的距离来计算距离V最近顶点即可。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prim1</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>m := <span class="hljs-built_in">len</span>(matrix)<br>dis := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>dis[i] = matrix[<span class="hljs-number">0</span>][i]<br>&#125;<br>status := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>, m)<br><br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m<span class="hljs-number">-1</span>; i++ &#123; <span class="hljs-comment">// 需要找剩余的点</span><br>t := <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123; <span class="hljs-comment">// 每次遍历剩余的所有点</span><br><span class="hljs-keyword">if</span> !status[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j]) &#123;<br>t = j<br>&#125;<br>&#125;<br>res += dis[t]<br>fmt.Println(i, t, dis[t])<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123;<br><span class="hljs-keyword">if</span> matrix[t][j] &lt; dis[j] &#123;<br>dis[j] = matrix[t][j]<br>&#125;<br>&#125;<br>status[t] = <span class="hljs-literal">true</span><br>&#125;<br>fmt.Println(res)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>matrix := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">128</span>&#125;,<br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">128</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br>prim(matrix)<br>fmt.Println()<br>prim1(matrix)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floyd算法</title>
    <link href="/2021/04/11/Floyd%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/11/Floyd%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="floyd-算法">Floyd 算法</h2><p>  Floyd算法也是求最短路径的一种算法，主要用于计算两两节点之间最短的距离。不像dijstra是固定一个起点，在Floyd中每一个点都可以是起点，用来计算它到其它节点之间的最短距离。其实Floyd就像是执行了n次dijstra算法。</p><span id="more"></span><h2 id="算法描述">算法描述</h2><p>  给定一个带权重的图G=(V,E)，可以存在负权(但不能存在负权环路)。V代表顶点的集合，E代表顶点之间的权重。</p><p>我们要计算任意两个顶点之间最短距离。</p><p>1、<strong>例如：AB两个顶点之间的最短距离不一定是A直接到B的距离，有可能是A经过C之后再去B得到的最短距离</strong>。</p><p>2、我们可以称C为AB的媒介，那怎样去找这些媒介呢？</p><p>3、<strong>遍历</strong>，没错就是遍历其它点，若存在一个媒介可以是Dis(A, C) + Dis(C, B) &lt; Dis(A, B)，则我们就可以更新Dis(A, B)=Dis(A, C) + Dis(C, B)。最终遍历完一遍，我们就能知道AB之间的最短距离了。</p><p>4、因此，<strong>我们在计算的过程中可以不断的更新两个点之间的最短距离</strong>。</p><h2 id="代码逻辑">代码逻辑</h2><p>   代码很好理解，就是<strong>三重循环</strong>，最外层表示媒介，里面两层表示两个端点。同时我们用tPath这个变量记录任意两点之间最短距离经过的路径，若两点之间不存在媒介，则<span class="math inline">\(tPath[i][j]=-1\)</span>，表示二者之间直接连接就是最短路径。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-comment">//https://juejin.im/post/5cc79c93f265da035b61a42e</span><br><br><span class="hljs-keyword">type</span> Floyd <span class="hljs-keyword">struct</span> &#123;<br>tTwoPointDis [][]<span class="hljs-keyword">int</span><br>tPath        [][]<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Floyd)</span> <span class="hljs-title">Init</span><span class="hljs-params">(tDis [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>f.tTwoPointDis = tDis<br><br>r := <span class="hljs-built_in">len</span>(tDis)<br><br>f.tPath = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, r)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f.tPath &#123;<br>f.tPath[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, r)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; r; j++ &#123;<br>f.tPath[i][j] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Floyd)</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;before&quot;</span>)<br><span class="hljs-keyword">for</span> _, tNums := <span class="hljs-keyword">range</span> f.tTwoPointDis &#123;<br><span class="hljs-keyword">for</span> _, tNum := <span class="hljs-keyword">range</span> tNums &#123;<br>fmt.Print(tNum, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br>r := <span class="hljs-built_in">len</span>(f.tTwoPointDis)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; r; k++ &#123; <span class="hljs-comment">// 媒介</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; r; j++ &#123;<br><span class="hljs-keyword">if</span> f.tTwoPointDis[i][j] &gt; (f.tTwoPointDis[i][k] + f.tTwoPointDis[k][j]) &#123;<br>f.tPath[i][j] = k <span class="hljs-comment">// 记录媒介</span><br>f.tTwoPointDis[i][j] = f.tTwoPointDis[i][k] + f.tTwoPointDis[k][j]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;after&quot;</span>)<br><span class="hljs-keyword">for</span> _, tNums := <span class="hljs-keyword">range</span> f.tTwoPointDis &#123;<br><span class="hljs-keyword">for</span> _, tNum := <span class="hljs-keyword">range</span> tNums &#123;<br>fmt.Print(tNum, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; r; j++ &#123;<br><span class="hljs-keyword">if</span> i != j &#123;<br>fmt.Println(f.getPath(i, j))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Floyd)</span> <span class="hljs-title">getPath</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-comment">// 打印路径</span><br><span class="hljs-keyword">if</span> f.tPath[i][j] == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span> + strconv.Itoa(i) + <span class="hljs-string">&quot; &quot;</span> + strconv.Itoa(j)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>k := f.tPath[i][j]<br><span class="hljs-keyword">return</span> f.getPath(i, k) + f.getPath(k, j)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tDis := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">127</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">127</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>&#125;&#125;<br><br>f := <span class="hljs-built_in">new</span>(Floyd)<br>f.Init(tDis)<br>f.solve()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>  ok，这就是floyd算法，我们不能被它的名字给吓住了。其实就是利用三重循环，计算图中任意两点的最短距离。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排课程</title>
    <link href="/2021/01/10/%E6%8E%92%E8%AF%BE%E7%A8%8B/"/>
    <url>/2021/01/10/%E6%8E%92%E8%AF%BE%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="排课程">排课程</h2><p>  Leetcode上有这样一道题，给定N个课程，但是有的课再学习之前，需要先学完别的某一个课程。就像我们在大学里面学专业之前要先学会高数才行。</p><p>  题目链接 <a href="https://leetcode.com/problems/course-schedule/">https://leetcode.com/problems/course-schedule/</a>，描述如下：</p><p>  There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses-1</code>.</p><span id="more"></span><p>  Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>  Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p>如上面的描述，给定课程数N，以及prerequisites [[0, 1]]，表示我们在学课程0之前要先把课程1学了，请我们计算最终是否能学完全部的课程。</p><p>整个问题梳理一下就是我们要先学一部分课程，然后再去学另一部分课程。但是存在一些<strong>特例</strong>，假如requisites=[[0, 1], [1, 0]]，第一个表示我们在学课程0之前要把课程1学完，第二个表示我们在学课程1之前把课程0学完。这样就形成了<strong>循环依赖</strong>，不能学完所有的课程。</p><p>  最初我的想法是构建链表，即利用链表构建每一个门课程之间的关系，但是链表是一一连接的，而课程之间可以存在一对多连接，比如学完课程1我可以学课程2 3，[[2,1],[3,1]]这种情况。因此我们就不能用链表来表示这种结构，后来看到网友的提示可以用图来表示。因此考虑用图来表示，我们将每一门课程表示一个顶点，若某课程B需要先学课程A才可以学，则在AB之间连接一条线，同时记录该课程B的<strong>连接数(出度)</strong>，我们要优先处理那些<strong>出度为0</strong>(不需要依赖其它课程)的课程，学完出度为0的课程之后，对于那些与其连接的课程<strong>出度要减一</strong>，表示我所依赖的课程数少了一个，若当前所依赖的课程为0，则将该课程加入待学的课程队列。最后，若仍然存在出度不为0的课程，表示不可以完成这些课，所所有的课程出度都为0，则可以完成这些课程。BFS的做法：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>graph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(prerequisites)) <span class="hljs-comment">// 建立图 </span><br>in := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)  <span class="hljs-comment">// 记录出度</span><br><span class="hljs-keyword">var</span> queue []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> prerequisites &#123;<br>graph[a[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(graph[a[<span class="hljs-number">1</span>]], a[<span class="hljs-number">0</span>]) <span class="hljs-comment">// key为先学的课程</span><br>in[a[<span class="hljs-number">0</span>]]++<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123; <span class="hljs-comment">// 出度为0的课程加入队列</span><br><span class="hljs-keyword">if</span> in[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>front := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[front] &#123; <span class="hljs-comment">// 与其相关课程的出度减一</span><br>in[next]--<br><span class="hljs-keyword">if</span> in[next] == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 若出度为0，加入队列</span><br>queue = <span class="hljs-built_in">append</span>(queue, next)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, pre := <span class="hljs-keyword">range</span> in &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>numCourses := <span class="hljs-number">2</span><br>prerequisite := [][]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;<br>fmt.Println(canFinish(numCourses, prerequisite))<br>&#125;<br></code></pre></td></tr></table></figure><p>此题还有一个延伸，若能学完所有的课程，返回课程的学习顺序。<a href="https://leetcode.com/problems/course-schedule-ii/">https://leetcode.com/problems/course-schedule-ii/</a>，其实我们只需要在上面的for循环中，没出现一个出度为0的课程，将其加入到结果中即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>&#125;<br><br>graph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(prerequisites))<br>in := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)<br><span class="hljs-keyword">for</span> _, pre := <span class="hljs-keyword">range</span> prerequisites &#123;<br>graph[pre[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(graph[pre[<span class="hljs-number">1</span>]], pre[<span class="hljs-number">0</span>])<br>in[pre[<span class="hljs-number">0</span>]]++<br>&#125;<br><br><span class="hljs-keyword">var</span> queue []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> in[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>front := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br>res = <span class="hljs-built_in">append</span>(res, front) <span class="hljs-comment">// 将课程编号加入到结果中</span><br><span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[front] &#123;<br>in[next]--<br><span class="hljs-keyword">if</span> in[next] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, next)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == numCourses &#123;<br><span class="hljs-keyword">return</span> res<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外还有一种基于DFS的做法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder1</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> numCourses == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;<br>&#125;<br><br>graph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(prerequisites))<br><span class="hljs-keyword">for</span> _, pre := <span class="hljs-keyword">range</span> prerequisites &#123;<br>graph[pre[<span class="hljs-number">0</span>]] = <span class="hljs-built_in">append</span>(graph[pre[<span class="hljs-number">0</span>]], pre[<span class="hljs-number">1</span>]) <span class="hljs-comment">// key为后学的课程</span><br>&#125;<br>visited := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)<br><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> !dfsFindOrder(graph, &amp;visited, i, &amp;res) &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfsFindOrder</span><span class="hljs-params">(graph <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>, visited *[]<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>, res *[]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> (*visited)[i] == <span class="hljs-number">0</span> &#123;<br>(*visited)[i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(graph[i]); k++ &#123;<br><span class="hljs-keyword">if</span> !dfsFindOrder(graph, visited, graph[i][k], res) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>(*visited)[i] = <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*visited)[i] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>*res = <span class="hljs-built_in">append</span>(*res, i)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>numCourse := <span class="hljs-number">4</span><br>prerequisites := [][]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;&#125;<br>fmt.Println(findOrder(numCourse, prerequisites))<br>fmt.Println(findOrder1(numCourse, prerequisites))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述的做法是基于DFS，首先还是建立一个图，然后利用visited记录每一个课程的状态，0:未学，1:正在学，2:学完。DFS的图和BFS的图不一样，graph中的key是不同的。在BFS中key是要先学的课程，DFS中的key是要后学的课程。DFS的做法，有一种倒序DFS的意思，即遍历每一门课程，若该课程的状态是0，则先置为1，然后去找它所依赖的其它课程，若依赖的课程为0，则置为1，继续向前找，找到所有依赖的课程都是未学，则表示这条路是可行的，至少没有循环依赖，则把这些课全部置为2已学。若先前着的过程中某个课是学完的，则表示这条路也是可行的，继续找其它分支的依赖的课程，若都是学完的，则把这条路经过的课程置为2已学。若向前找的过程中某个课程是正在学的，表示存在循环依赖，不可行，直接返回。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alogithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>延迟接受算法</title>
    <link href="/2020/07/18/%E5%BB%B6%E8%BF%9F%E6%8E%A5%E5%8F%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/18/%E5%BB%B6%E8%BF%9F%E6%8E%A5%E5%8F%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="延迟接受算法">延迟接受算法</h2><p>  延迟接受算法是一个比较经典的优化算法，也叫做盖尔-沙普利算法，是盖尔和沙普利为了寻找一个稳定<a href="https://baike.baidu.com/item/匹配/6397551">匹配</a>而设计出的市场机制。从算法的角度来讲，延迟接受就是对当前解不会立即接受，而是暂时的不被拒绝，当迭代次数停止以后，会从手上选择最优的那一个作为最终解。</p><span id="more"></span><h2 id="问题描述">问题描述</h2><p>  我们有一个要优化的目标<span class="math inline">\(f(x,y,z)=x^2 \ast z-y^3 \ast z^2+x^2 \ast y^3-x/y\)</span>，<span class="math inline">\(x,y,z\)</span>的范围都是[0, 100]，我们就要在这个范围内求出函数<span class="math inline">\(f(x,y,z)\)</span>的最小值。由于解空间比较大，我们无法在常数时间内取得最优解，所以只能考虑启发式的方式来寻求局部最优解。<strong>启发式</strong>方法可以简单的理解为我们给定一个初始解，然后在该初始解的邻域范围内进行搜索，最终获得一个局部最优解(全局最优解)。<strong>延迟接受</strong>就是一种求解方法。</p><h2 id="算法描述">算法描述</h2><p>  延迟接受算法就是将当前的新解与<span class="math inline">\(n\)</span>步之前的解进行对比，若当前解优于<span class="math inline">\(n\)</span>步以前的解，则直接接受当前解，若比<span class="math inline">\(n\)</span>步之前的解差，则拒绝当前解。</p><p>  延迟接受还有一个变种，就是带爬山的延迟接受( Late Acceptance Hill-Climbing)，从名字上也可以看出，“带爬上”其实就是引入了爬上的思路，即当前解与上一步的解来比较，若优于上一步解，则直接接受新解，否则拒绝。</p><figure><img src="/images/lahc.jpg" alt="lahc" /><figcaption aria-hidden="true">lahc</figcaption></figure><p>延迟接受算法的流程如上图所示，</p><p>1、<span class="math inline">\(s\)</span>为初始解，<span class="math inline">\(C\left(s\right)\)</span>为初始解的函数值，<span class="math inline">\(Lfa\)</span>就是延迟接受的步长，我们可以以一个队列或者数组来存储延迟接受的<span class="math inline">\(Lfa\)</span>个解，初始解都为<span class="math inline">\(C(s)\)</span>。</p><p>2、开始迭代，构建新解<span class="math inline">\(s\ast\)</span>，计算新解的函数值<span class="math inline">\(C(s\ast)\)</span>。</p><p>3、计算<span class="math inline">\(Lfa\)</span>步之前的解的函数值<span class="math inline">\(f(v)\)</span>，<span class="math inline">\(v := I \% Lfa\)</span>，<span class="math inline">\(v\)</span>相对于<span class="math inline">\(I\)</span>就是<span class="math inline">\(Lfa\)</span>步之前解的函数值。</p><p>4、比较 <span class="math inline">\(C(s\ast)\)</span> 和 <span class="math inline">\(f(v)\)</span>，比较 <span class="math inline">\(C(s*)\)</span> 和 <span class="math inline">\(C(s)\)</span>，若<span class="math inline">\(C(s\ast)\)</span>优于<span class="math inline">\(f(v)\)</span>或者<span class="math inline">\(C(s)\)</span>，则直接接受当前新解<span class="math inline">\(s\ast\)</span>，并更新<span class="math inline">\(f(v)=C(s\ast)\)</span>。</p><p>5、若<span class="math inline">\(C(s*)\)</span> 差于<span class="math inline">\(f(v)\)</span> 或者 <span class="math inline">\(C(s)\)</span>，则更新 <span class="math inline">\(f(v)=C(s)\)</span>。</p><p>6、I=I+1，直到迭代终止。</p><p>上面就是延迟接受的整个流程，最关键的是第4和第5步，尤其第5步，当前新解比之前n步的解或者上一步的解要差时，应该是将上一步的解重新更新到n步之前的位置。</p><h2 id="算法应用">算法应用</h2><p>  我们可以将延迟接受算法应用到TSP问题中，TSP问题也是一个NP-hard问题，可以采用启发式算法的方式去进行求解。</p><p>部分代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> algorithm<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;TSP/ioinfo&quot;</span><br><span class="hljs-string">&quot;TSP/util&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> LateAcceptance <span class="hljs-keyword">struct</span> &#123;<br>n       <span class="hljs-keyword">int</span><br>tScore []<span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LateAcceptance)</span> <span class="hljs-title">Init</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, pStartScore <span class="hljs-keyword">float64</span>)</span></span> &#123;<br>l.n = n + <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l.n; i++ &#123;<br>l.tScore = <span class="hljs-built_in">append</span>(l.tScore, pStartScore)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LateAcceptance)</span> <span class="hljs-title">Accept</span><span class="hljs-params">(pScore <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">var</span> pAccept <span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">if</span> pScore &lt;= l.tScore[<span class="hljs-number">0</span>] &#123;<br>pAccept = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pScore &lt;= l.tScore[<span class="hljs-built_in">len</span>(l.tScore) - <span class="hljs-number">1</span>] &#123;<br>pAccept = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pAccept = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> pAccept &#123;<br>l.tScore = <span class="hljs-built_in">append</span>(l.tScore, pScore)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l.tScore = <span class="hljs-built_in">append</span>(l.tScore, l.tScore[<span class="hljs-built_in">len</span>(l.tScore) - <span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l.tScore) &gt;= l.n &#123;<br>l.tScore = l.tScore[<span class="hljs-number">1</span>:]<br>&#125;<br><br><span class="hljs-keyword">return</span> pAccept<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changCity1</span><span class="hljs-params">(dataSrc []ioinfo.Data, R1 rand.Rand)</span> []<span class="hljs-title">ioinfo</span>.<span class="hljs-title">Data</span></span> &#123;<br>pos1 := R1.Intn(<span class="hljs-built_in">len</span>(dataSrc)<span class="hljs-number">-3</span>) + <span class="hljs-number">1</span><br>pos2 := R1.Intn(<span class="hljs-built_in">len</span>(dataSrc)-pos1<span class="hljs-number">-1</span>) + pos1<br>dataDest := <span class="hljs-built_in">make</span>([]ioinfo.Data, <span class="hljs-built_in">len</span>(dataSrc))<br><span class="hljs-built_in">copy</span>(dataDest, dataSrc)<br>r := R1.Intn(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> pos1 &lt; pos2 &#123;<br>dataDest[pos1], dataDest[pos2] = dataDest[pos2], dataDest[pos1]<br>pos1 ++<br>pos2 --<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dataDest[pos1], dataDest[pos2] = dataDest[pos2], dataDest[pos1]<br>&#125;<br><br><span class="hljs-keyword">return</span> dataDest<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">La</span><span class="hljs-params">(pFileName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>data := util.GetSampleData(pFileName, <span class="hljs-literal">false</span>)<br>r := util.GetResult(data)<br><br>pLa := <span class="hljs-built_in">new</span>(LateAcceptance)<br>pLa.Init(<span class="hljs-number">215</span>, r)<br><br><span class="hljs-keyword">var</span> R1 = rand.New(rand.NewSource(<span class="hljs-number">0</span>))<br><br>s1 := time.Now().UnixNano()<br>pIterNum := <span class="hljs-number">200000</span><br><span class="hljs-keyword">for</span> pIterNum &gt; <span class="hljs-number">0</span> &#123;<br>temp := changCity1(data, *R1)<br>rn := util.GetResult(temp)  <span class="hljs-comment">// 计算当前解的里程 </span><br><span class="hljs-keyword">if</span> pLa.Accept(rn) &#123;<br>data = temp<br>&#125;<br>pIterNum--<br>&#125;<br>s2 := time.Now().UnixNano()<br>fmt.Println(data, s2 -s1)<br><span class="hljs-keyword">return</span> util.GetResult(data)<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">延迟接受启动：<br>[ 1 -&gt; 43 -&gt; 23 -&gt; 56 -&gt; 41 -&gt; 42 -&gt; 64 -&gt; 61 -&gt; 69 -&gt; 36 -&gt; 37 -&gt; 71 -&gt; 60 -&gt; 70 -&gt; 20 -&gt; 15 -&gt; 57 -&gt; 27 -&gt; 52 -&gt; 13 -&gt; 54 -&gt; 19 -&gt; 59 -&gt; 14 -&gt; 53 -&gt; 11 -&gt; 66 -&gt; 65 -&gt; 38 -&gt; 31 -&gt; 10 -&gt; 58 -&gt; 72 -&gt; 39 -&gt;  9 -&gt; 40 -&gt; 12 -&gt; 17 -&gt; 76 -&gt; 26 -&gt;  7 -&gt; 35 -&gt;  8 -&gt; 46 -&gt; 34 -&gt; 67 -&gt; 75 -&gt;  4 -&gt; 45 -&gt; 29 -&gt;  5 -&gt; 48 -&gt; 47 -&gt; 21 -&gt; 74 -&gt; 30 -&gt;  2 -&gt; 68 -&gt;  6 -&gt; 51 -&gt;  3 -&gt; 44 -&gt; 32 -&gt; 50 -&gt; 25 -&gt; 55 -&gt; 18 -&gt; 24 -&gt; 49 -&gt; 16 -&gt; 63 -&gt; 33 -&gt; 73 -&gt; 62 -&gt; 28 -&gt; 22 -&gt;  1 -&gt;] 170124000ns<br>588.1953208548182<br><br></code></pre></td></tr></table></figure><p>76个点需要170ms，最终结果588.195</p><p>全局最优解为545.3875524687445，延迟接受的解比全局最优解差7%左右，结果还是可以接受的。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>late acceptance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dijkstra算法</title>
    <link href="/2020/07/05/dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/05/dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="dijkstra算法">Dijkstra算法</h2><p>  中文名又叫迪杰斯特拉算法，是一种单源最短路径算法，用于计算一个节点到其它所有节点的最短路径。通俗的讲就是确定好一个起点之后，计算起点到其它点最短路径。常用于一些路由计算或者路径规划等场景。</p><span id="more"></span><h2 id="算法描述">算法描述</h2><p>  给定一个带权有向图G=(V, E)，V代表顶点集合，E代表顶点之间的权重。</p><p>1、把顶点分成两个集合S、U，S代表已经获得最短路径的顶点，起初只有源点一个，U代表未加入路径的顶点。（保持源点s到S中各个顶点的最短路径长度不大于源点s到U中各个顶点的最短路径长度）</p><p>2、从U中选出一个顶点k，是从源点到U中所有顶点距离最短的一个，将k加入S，并从U中移除顶点k</p><p>3、根据S中现有的顶点，更新s到U中各个顶点的距离，比如之前s-&gt;m的距离是无穷大，现在经过（s-&gt;k） + （k-&gt;m）为常数值。</p><p>4、重复2、3两步，直到U中的顶点为空</p><h2 id="代码逻辑">代码逻辑</h2><p>  整体的代码逻辑也很简单，首先我们需要两个列表，一个表示访问过的点S一个表示未访问过的点U。一个map path 用于存储从源点到已访问过点的路径。然后我们每次只需要计算从源点s经过S中的某个/某些点之后 到 U中各个点的距离，只需要找出到U中距离最短的点即可。我们可以把S中最后一个经过的点称之为pre，U中访问的点为next，找到路径最短的next之后，我们将next移动到S中。并且源点s到next的路径只是在源点s到pre的基础上加了个u，将s-&gt;u的路径加入到path中即可。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// https://github.com/muzixing/graph_algorithm/blob/master/dijkstra.py</span><br><br><span class="hljs-keyword">const</span>(<br>MaxDis  <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span><span class="hljs-number">-1</span><br>)<br><br><span class="hljs-keyword">type</span> Dijkstra <span class="hljs-keyword">struct</span> &#123;<br>tPints  []<span class="hljs-keyword">string</span><br>tTwoPointDis <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dijkstra)</span> <span class="hljs-title">Init</span><span class="hljs-params">(tPoints []<span class="hljs-keyword">string</span>, tDis [][]<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tPoints) != <span class="hljs-built_in">len</span>(tDis) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;点数与矩阵的大小不一致&quot;</span>)<br>&#125;<br>d.tTwoPointDis = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tPoints); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(tPoints); j++ &#123;<br>key := tPoints[i] + <span class="hljs-string">&quot;_&quot;</span> + tPoints[j]<br>d.tTwoPointDis[key] = tDis[i][j]<br>&#125;<br>&#125;<br>d.tPints = tPoints<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dijkstra)</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span> &#123;<br>tPoints := d.tPints[<span class="hljs-number">1</span>:]                  <span class="hljs-comment">// 未访问过的点</span><br>visited := []<span class="hljs-keyword">string</span>&#123;d.tPints[<span class="hljs-number">0</span>]&#125;         <span class="hljs-comment">// 访问过的点</span><br>src := d.tPints[<span class="hljs-number">0</span>]                       <span class="hljs-comment">// 起点</span><br>pre, next := src, src<br><br>path := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)     <span class="hljs-comment">// 起点到其它点的路径</span><br>path[src + <span class="hljs-string">&quot;_&quot;</span> + src] = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>&#125;<br><br>distanceGraph := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 起点到其它点的距离</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(tPoints) &gt; <span class="hljs-number">0</span> &#123;<br>distance := MaxDis<br><span class="hljs-keyword">var</span> ind <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> dst <span class="hljs-keyword">string</span><br><br><span class="hljs-keyword">var</span> nextInd <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> visited &#123;<br><span class="hljs-keyword">for</span> ind, dst = <span class="hljs-keyword">range</span> tPoints &#123;<br>newDis := d.tTwoPointDis[src + <span class="hljs-string">&quot;_&quot;</span> + v] + d.tTwoPointDis[v + <span class="hljs-string">&quot;_&quot;</span> + dst]  <span class="hljs-comment">// 从起点src到已访问过的点v + 从v到未访问过点的距离</span><br><span class="hljs-keyword">if</span> newDis &lt; distance &#123;<br>distance = newDis<br>pre = v<br>next = dst<br>nextInd = ind<br>d.tTwoPointDis[src + <span class="hljs-string">&quot;_&quot;</span> + dst] = distance<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> _, tPoint := <span class="hljs-keyword">range</span> path[src + <span class="hljs-string">&quot;_&quot;</span> + pre] &#123;<br>path[src + <span class="hljs-string">&quot;_&quot;</span> + next] = <span class="hljs-built_in">append</span>(path[src + <span class="hljs-string">&quot;_&quot;</span> + next], tPoint)<br>&#125;<br>path[src + <span class="hljs-string">&quot;_&quot;</span> + next] = <span class="hljs-built_in">append</span>(path[src + <span class="hljs-string">&quot;_&quot;</span> + next], next)  <span class="hljs-comment">// 记录从src到next需经过的路径</span><br><br>distanceGraph[src + <span class="hljs-string">&quot;_&quot;</span> + next] = distance                     <span class="hljs-comment">// 记录从src到next的距离</span><br><br>visited = <span class="hljs-built_in">append</span>(visited, next)<br>tPoints = <span class="hljs-built_in">append</span>(tPoints[:nextInd], tPoints[nextInd+<span class="hljs-number">1</span>:]...)<br>&#125;<br><br>fmt.Println(path)<br>fmt.Println(distanceGraph)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := <span class="hljs-built_in">new</span>(Dijkstra)<br>tPoints := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;<br>tDis := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>,      <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">127</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">127</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>&#125;&#125;<br><br>d.Init(tPoints, tDis)<br>d.dijkstra()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>  Ok，整体的代码逻辑就是这样的，从最初不了解dijkstra算法，到了解用代码实现之后，发现其中的逻辑不算复杂。只要我们能够理解S U两个列表，以及中间状态的存储path，还有如何从U中获得下一个要访问的点。整个问题就解决了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive/SQL日常总结</title>
    <link href="/2020/05/16/Hive-SQL%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/16/Hive-SQL%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="hivesql日常总结">Hive/SQL日常总结</h1><p>  说来惭愧，工作了有一段时间了，才开始接触SQL。自己之前从来没有和SQL打过交道。为了不在工作中拖后腿，自己挤时间把《SQL必知必会》这本书看完了。看完之后虽然对SQL有了基本的认识，但是应用起来还是不太熟练，有时候还需要上网查一查相关资料才用。现在把日常使用中会用到的点记录下来，方便以后应用。</p><span id="more"></span><h2 id="如何比较两个表的内容是否完全一致">1、如何比较两个表的内容是否完全一致</h2><h3 id="分组-inner-join">（1）、分组 inner join</h3><p>  这个问题我一直没有找到比较简洁有效的方式。看网上有一种做法，假设我们有两个表t1， t2。</p><p>  首先对t1按行分组，计算分组的条数num1。</p><p>  然后对t2按行分组，计算分组的条数num2。</p><p>  最后两个表t1、t2进行inner join，按照所有的列名字以及num进行关联。</p><p>  若num1=num2=inner join之后的条数，则说明两个表的内容完全一致。</p><p>  假设表结构如下所示，只有两列</p><table><thead><tr class="header"><th style="text-align: center;">id</th><th style="text-align: center;">name</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">xx1</td><td style="text-align: center;">Tom</td></tr><tr class="even"><td style="text-align: center;">xx2</td><td style="text-align: center;">Jone</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs sql">对t1进行分组<br><span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br><span class="hljs-keyword">from</span> t1 <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name;<br><br>对t2进行分组<br><span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br><span class="hljs-keyword">from</span> t2 <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name;<br><br>使用t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br>  (<span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br>  <span class="hljs-keyword">from</span> t1 <br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name) <span class="hljs-keyword">as</span> tmp1<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span><br>   (<span class="hljs-keyword">select</span> id, name <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <br>    <span class="hljs-keyword">from</span> t2 <br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id, name) <span class="hljs-keyword">as</span> tmp2<br> <span class="hljs-keyword">on</span> tmp1.id<span class="hljs-operator">=</span>tmp2.id <span class="hljs-keyword">and</span> tmp1.name<span class="hljs-operator">=</span>tmp2.name;<br></code></pre></td></tr></table></figure><p>  若上面第一步num1值等于第二步的num2值，并且等于第三步输出的个数，说明两个表的内容是完全一样的。这个做法对于表的column比较少的情况比较方便，一旦column很大的情况下写起来就不太方便了。</p><h3 id="minus-做减法">（2）、minus 做减法</h3><p>  另一种做法是直接用两个表相互做减法，看返回的是否均为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1<br>minus <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2<br>minus<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1;<br></code></pre></td></tr></table></figure><p>如果返回的内容均为空的话，就说明两个表的内容完全一致，但是<strong>对于表中有重复的行的话这种方法就不适用了。</strong> 还有我在hue页面尝试这个方法的时候，提示我没有minus这个关键字。下次得去hive客户端试试了。</p><p><a href="https://zhuanlan.zhihu.com/p/113617244"></a></p><h2 id="分区表字段处理">2、分区表字段处理</h2><h3 id="增加新的字段">1、增加新的字段</h3><p>  之前遇到一个问题，就是一个非空分区表需要添加新的字段，然后把数据写入进去。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_nam <span class="hljs-keyword">add</span> columns(c1 <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>添加完字段之后，发现写入进去之后c1这个列全为null，当时以为是自己计算的错误。然后我在写入之前查了下，发现c1这个字段的数据是有的并且不为null，但是但是写入之后就为null了。后来查资料说到是添加新的字段的方式有问题，然后只能把那个表删掉，重新建表，写入数据。</p><p>对于非空分区表添加新的字段的正确方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">add</span> columns(c1 <span class="hljs-type">int</span>) cascade;<br></code></pre></td></tr></table></figure><p><a href="https://community.cloudera.com/t5/Community-Articles/Adding-new-columns-to-an-already-partitioned-Hive-table/ta-p/245636"></a></p><p><a href="https://blog.csdn.net/aijiudu/article/details/79066835"></a></p><h3 id="调整字段的位置">2、调整字段的位置</h3><p>  有时候我们的表建好，写入数据之后，又想添加新的字段，或者想把一些物理意义较近的字段放在一起，所以我们需要调整字段，所以如何调整字段的位置呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name c1 c1 <span class="hljs-type">float</span> after c2 cascade;<br></code></pre></td></tr></table></figure><p>  上面的sql就是把float类型的c1字段移动到c2后面，对于分区表注意使用cascade哦。</p><h2 id="将一个表的内容写入到另一个表中">3、将一个表的内容写入到另一个表中</h2><p>  如果是覆盖原始数据的话，直接使用insert overwrite</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> overwrite <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">partition</span>(dt<span class="hljs-operator">=</span>’t’)<br>       <span class="hljs-keyword">Select</span> col1, col2, col2,….<br>       <span class="hljs-keyword">From</span> table_name<br>       <span class="hljs-keyword">Where</span> dt<span class="hljs-operator">=</span>’t<span class="hljs-number">-1</span>’<br><br></code></pre></td></tr></table></figure><p>上面是将同一个表中一个分区的写入到另一个分区内。</p><p>  直接写入一个分区内，相当于追加到对应的分区内。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">partition</span>(dt<span class="hljs-operator">=</span>’t’)<br>       <span class="hljs-keyword">Select</span> col1, col2, col2,….<br>       <span class="hljs-keyword">From</span> table_name<br>       <span class="hljs-keyword">Where</span> dt<span class="hljs-operator">=</span>’t<span class="hljs-number">-1</span>’<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：分区字段要写完整</p><p>​ 选择数据时不能使用 select <em>， 因为select </em> 会选中所有字段，包括分区字段，但是我们写入的表中分区字段是作为文件夹名字的， 即实际表中没有分区字段，假如我们表中有7个字段（非分区字段），另外还有4个分区字段，我们在select * 的时候会选出11个字段，但是我们写入的表只有7个字段需要被写入，这样的话就会报错。</p><p>因此我们在选择数据时，要用select 选出那7个非分区字段。</p><h2 id="创建表的方式">4、创建表的方式</h2><h3 id="直接建表法">1、直接建表法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1(<br>    id      <span class="hljs-type">int</span>,<br>    name    string,<br>    hobby   <span class="hljs-keyword">array</span><span class="hljs-operator">&lt;</span>string<span class="hljs-operator">&gt;</span>,<br>    <span class="hljs-keyword">add</span>     map<span class="hljs-operator">&lt;</span>String,string<span class="hljs-operator">&gt;</span><br>)<br><span class="hljs-type">row</span> format delimited<br>fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span><br>collection items terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;-&#x27;</span><br>map keys terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;:&#x27;</span><br>;<br></code></pre></td></tr></table></figure><p>然后load data进入到表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> inpath <span class="hljs-string">&#x27;/user/hive/warehouse/...data&#x27;</span> overwrite <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> t1;<br></code></pre></td></tr></table></figure><h3 id="select-方法">2、select 方法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1 <span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span><br>    id,<br>    name<br><span class="hljs-keyword">from</span> t2;<br></code></pre></td></tr></table></figure><h3 id="like建表法">3、like建表法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1<br><span class="hljs-keyword">like</span> t2;<br></code></pre></td></tr></table></figure><h2 id="删除文件">5、删除文件</h2><h3 id="删除文件-1">1、删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -rm -r /user/hive/warehouse/database/table_name/dt=xxxx/city_code=xxxxx<br><br></code></pre></td></tr></table></figure><p>上述命令直接在terminal中执行即可，其实就是常用的linux命令前面加上hadoop fs，还有列出某个表的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hadoop fs -ls /user/hive/warehouse/database/table_name/dt=xxxx<br></code></pre></td></tr></table></figure><h3 id="删除分区">2、删除分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">alter table table_name drop if exists partition(dt=xxxx, city_code=xxxx);<br><br></code></pre></td></tr></table></figure><p>上述命令需要在hive客户端中执行。</p><h2 id="时间处理">6、时间处理</h2><h3 id="转换为时间戳">1、转换为时间戳</h3><p>标准格式是指'2021-06-30 10:10:00'这种格式，即'yyyy-MM-dd HH:mm:ss'，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unix_timestamp(<span class="hljs-string">&#x27;2021-06-30 10:10:10&#x27;</span>)<br></code></pre></td></tr></table></figure><p>若时间不是标准格式的，比如 '20210630'这种的情况，也可以使用unix_timestamp来转换，但是需要你传入格式，即告诉这个函数你的时间是什么格式的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unix_timestamp(<span class="hljs-string">&#x27;20210630&#x27;</span>, <span class="hljs-string">&#x27;yyyyMMdd&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="时间戳转换为日期">2、时间戳转换为日期</h3><p>时间戳转换为标准格式/指定格式，需要用到from_unixtime(date, format)，此时的时间是到秒级的，即你的时间戳长度为10位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">from_unixtime(<span class="hljs-string">&#x27;1625839005&#x27;</span>, <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)<span class="hljs-operator">/</span>from_unixtime(<span class="hljs-string">&#x27;1625839005&#x27;</span>, <span class="hljs-string">&#x27;yyyy-MM-dd&#x27;</span>)<br></code></pre></td></tr></table></figure><p>对于一些时间戳是到毫秒级其长度为13位，因此我们在转换前需要先取其前10位，即<strong>对字符串进行截取指定长度</strong>，这个在mysql和hivesql中是由一些差异的。<strong>在mysql中有left，right两个函数，但是在hive中可以使用substr来做</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">from_unixtime((<span class="hljs-built_in">cast</span>(substr(<span class="hljs-string">&#x27;1625839005000&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">bigint</span>)), <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="分位数">7、分位数</h2><p>在hivesql中，取分位数还是比较简单，有两个函数可供使用，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">percentile(col, p)<br></code></pre></td></tr></table></figure><p>col为我们要处理的列，但是要求col的值必须都为int，p为0-1的小数，表示分位数，0.3表示3分位数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">percentile_approx(col, <span class="hljs-keyword">array</span>(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>), <span class="hljs-number">9999</span>)<br></code></pre></td></tr></table></figure><p>col也是我们要处理的列，此时该列的值可以为浮点型也可以为整型，后面可以穿入一个array，一次取多个分位数</p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下压缩隐藏文件</title>
    <link href="/2020/05/03/Linux%E4%B8%8B%E5%8E%8B%E7%BC%A9%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"/>
    <url>/2020/05/03/Linux%E4%B8%8B%E5%8E%8B%E7%BC%A9%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下压缩文件">Linux下压缩文件</h1><p>  之前在压缩文件的时候一直使用tar这个命令，因为一般压缩的时候都是对我们能“看见”的文件进行压缩，没有考虑过那些看不见的文件，即“隐藏”文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz abc/*   // 压缩<br>tar zxvf abc.tar.gz         // 解压<br></code></pre></td></tr></table></figure><p>  最近在服务器上压缩文件时，需要用到里面的隐藏文件，想当然的进行了上面的压缩方式，解压之后发现找不到隐藏文件。一阵查找资料后才发想，上面的做法只是<strong>压缩指定文件夹下面的非隐藏文件与文件夹</strong>。</p><p>  因此查找资料后发现，对于隐藏和非隐藏文件的压缩方式还有些不同。如果想要对隐藏的文件做处理，需要<strong>显示的指定</strong>出来才可以。我们都知道隐藏的文件或文件夹都是以“.”开头的。所以就需要用到正则表达式来处理了：</p><span id="more"></span><h2 id="压缩非隐藏文件">压缩非隐藏文件</h2><p>  注意只压缩非隐藏文件，不包括文件夹的话是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zcvf abc.tar.gz *.*   // 压缩当前文件夹下非隐藏文件不包括文件夹<br></code></pre></td></tr></table></figure><p>  压缩所有的非隐藏文件，包括文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz *       <br></code></pre></td></tr></table></figure><h2 id="压缩隐藏文件">压缩隐藏文件</h2><p>  如果要压缩隐藏文件的话，要显示的指示出来</p><p>  压缩当前文件下的隐藏文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz .[!.]*   // 只压缩当前文件夹下隐藏文件排除两个隐藏文件夹&quot;.&quot;和“..”   <br></code></pre></td></tr></table></figure><p>上面的.[!.]其实就是正则表达式，表示第一个字符是“.”，第二个字符不是"."，第三个以及后面可以是任意字符。</p><p>  压缩当前文件夹下的所有文件夹以及隐藏的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zcvf abc.tar.gz .[!.]* *  // 压缩当前文件夹下所有文件和目录包括隐藏文件  <br></code></pre></td></tr></table></figure><p>这条命令比上一条命令多了一个*，表示当前文件夹下的所有文件以及文件夹。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
